<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Galaxy Instance Map - Geographic Distribution</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script src="https://d3js.org/topojson.v3.min.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      padding: 1rem;
    }

    .container {
      max-width: 1400px;
      margin: 0 auto;
      background: white;
      border-radius: 12px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
      overflow: hidden;
    }

    .header-section {
      background: linear-gradient(135deg, #2c3e50 0%, #3498db 100%);
      color: white;
      padding: 2rem;
    }

    .header-title {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      flex-wrap: wrap;
      gap: 2rem;
    }

    .title-section {
      display: flex;
      align-items: center;
      gap: 1rem;
    }

    .galaxy-logo {
      width: 60px;
      height: 60px;
      border-radius: 50%;
      background: white;
      padding: 8px;
    }

    h1 {
      font-size: 2.5rem;
      font-weight: 700;
      margin: 0;
      text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
    }

    .subtitle {
      font-size: 1.1rem;
      margin-top: 0.5rem;
      opacity: 0.9;
      font-weight: 300;
    }

    .summary-stats {
      display: flex;
      gap: 1rem;
      margin-top: 1rem;
    }

    .stat-box {
      background: rgba(255, 255, 255, 0.15);
      padding: 1rem;
      border-radius: 8px;
      text-align: center;
      min-width: 120px;
      backdrop-filter: blur(10px);
    }

    .stat-number {
      font-size: 2rem;
      font-weight: 700;
      margin-bottom: 0.25rem;
    }

    .stat-box div:last-child {
      font-size: 0.85rem;
      opacity: 0.9;
    }

    .search-container {
      margin-top: 1.5rem;
    }

    .search-input {
      width: 100%;
      padding: 0.75rem 1rem;
      border: 2px solid rgba(255, 255, 255, 0.2);
      border-radius: 8px;
      font-size: 1rem;
      background: rgba(255, 255, 255, 0.1);
      color: white;
      backdrop-filter: blur(10px);
    }

    .search-input::placeholder {
      color: rgba(255, 255, 255, 0.7);
    }

    .search-input:focus {
      outline: none;
      border-color: rgba(255, 255, 255, 0.5);
      background: rgba(255, 255, 255, 0.15);
    }

    .controls-section {
      padding: 1.5rem 2rem;
      background: #f8f9fa;
      border-bottom: 1px solid #e9ecef;
      display: flex;
      gap: 1rem;
      align-items: center;
      flex-wrap: wrap;
    }

    .view-toggle {
      display: flex;
      background: white;
      border-radius: 6px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      overflow: hidden;
    }

    .view-toggle button {
      padding: 0.5rem 1rem;
      border: none;
      background: white;
      color: #666;
      cursor: pointer;
      font-size: 0.9rem;
      transition: all 0.2s;
    }

    .view-toggle button.active {
      background: #2196f3;
      color: white;
    }

    .view-toggle button:hover:not(.active) {
      background: #f5f5f5;
    }

    button {
      padding: 0.5rem 1rem;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 0.9rem;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    button:hover {
      transform: translateY(-1px);
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
    }

    .refresh-btn {
      background: #2196f3;
      color: white;
    }

    .export-btn {
      background: #4caf50;
      color: white;
    }

    .map-container {
      position: relative;
      height: 600px;
      background: #f0f8ff;
      margin: 2rem;
      border-radius: 8px;
      overflow: hidden;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
    }

    #world-map {
      width: 100%;
      height: 100%;
      cursor: grab;
    }

    #world-map:active {
      cursor: grabbing;
    }

    .country {
      fill: #e8f5e8;
      stroke: #b8d8b8;
      stroke-width: 0.5px;
      cursor: pointer;
      transition: fill 0.2s;
    }

    .country:hover {
      fill: #d4f1d4 !important;
      stroke: #4caf50;
      stroke-width: 1px;
    }

    .ocean {
      fill: #e3f2fd;
      opacity: 0.6;
    }

    .cluster-details-container {
      background: #f8f9fa;
      border-top: 1px solid #e9ecef;
      max-height: 400px;
      overflow-y: auto;
    }

    .cluster-details-header {
      background: #343a40;
      color: white;
      padding: 1rem 2rem;
      display: flex;
      align-items: center;
      justify-content: space-between;
      font-weight: 600;
      font-size: 1.1rem;
    }

    .cluster-details-header i {
      margin-right: 0.5rem;
    }

    .close-btn {
      background: none;
      border: none;
      color: white;
      font-size: 1.2rem;
      cursor: pointer;
      padding: 0.25rem;
      border-radius: 4px;
      transition: background-color 0.2s;
    }

    .close-btn:hover {
      background: rgba(255, 255, 255, 0.1);
    }

    #cluster-details-content {
      padding: 0;
    }

    .cluster-details-table-container {
      overflow-x: auto;
      max-height: 350px;
      overflow-y: auto;
    }

    .cluster-details-table {
      width: 100%;
      border-collapse: collapse;
      background: white;
      font-size: 0.875rem;
    }

    .cluster-details-table th {
      background: #f8f9fa;
      color: #495057;
      font-weight: 600;
      padding: 0.75rem;
      text-align: left;
      border-bottom: 2px solid #dee2e6;
      position: sticky;
      top: 0;
      z-index: 1;
    }

    .cluster-details-table td {
      padding: 0.75rem;
      border-bottom: 1px solid #dee2e6;
      vertical-align: middle;
    }

    .cluster-details-table tbody tr:hover {
      background: #f8f9fa;
    }

    .tier-badge {
      background: #6c757d;
      color: white;
      padding: 0.2rem 0.5rem;
      border-radius: 12px;
      font-size: 0.75rem;
      font-weight: 500;
      white-space: nowrap;
    }

    .tier-1 { background: #4caf50; }
    .tier-2 { background: #ff9800; }
    .tier-3 { background: #2196f3; }
    .tier-4 { background: #9c27b0; }
    .tier-5 { background: #607d8b; }
    .tier-6 { background: #795548; }

    .description-info {
      line-height: 1.4;
      max-width: 300px;
    }

    .description-notes {
      font-size: 0.9em;
      color: #666;
      margin-top: 4px;
      font-style: italic;
    }

    .server-name {
      font-weight: 600;
      margin-bottom: 4px;
    }

    .server-url {
      color: #2196f3;
      text-decoration: none;
      font-size: 0.9em;
    }

    .server-url:hover {
      text-decoration: underline;
    }

    .location-info {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }

    .country-flag {
      margin-right: 6px;
    }

    .coordinates {
      font-family: monospace;
      font-size: 0.9em;
      color: #666;
    }

    .loading-indicator {
      display: inline-block;
      width: 12px;
      height: 12px;
      border: 2px solid #f3f3f3;
      border-top: 2px solid #2196f3;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-right: 0.5rem;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    .status-indicator {
      padding: 0.25rem 0.5rem;
      border-radius: 4px;
      font-size: 0.8rem;
      font-weight: 500;
      display: inline-flex;
      align-items: center;
      gap: 0.25rem;
    }

    .status-online {
      background: #e8f5e8;
      color: #2e7d32;
    }

    .status-issues {
      background: #fff3e0;
      color: #f57c00;
    }

    .status-offline {
      background: #ffebee;
      color: #c62828;
    }

    .no-results {
      text-align: center;
      padding: 2rem;
      color: #666;
      font-style: italic;
    }

    #status {
      margin: 2rem;
      padding: 1rem;
      border-radius: 8px;
      text-align: center;
      font-weight: 500;
    }

    .status-loading {
      background: #e3f2fd;
      border: 1px solid #2196f3;
      color: #1976d2;
    }

    .status-error {
      background: #ffebee;
      border: 1px solid #f44336;
      color: #c62828;
    }

    .status-success {
      background: #e8f5e8;
      border: 1px solid #4caf50;
      color: #2e7d32;
    }

    .navigation-links {
      margin: 2rem;
      text-align: center;
      display: flex;
      justify-content: center;
      gap: 2rem;
      flex-wrap: wrap;
    }

    .navigation-links a {
      color: #2196f3;
      text-decoration: none;
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-weight: 500;
      transition: color 0.2s;
    }

    .navigation-links a:hover {
      color: #1976d2;
    }

    .map-marker {
      cursor: pointer;
      transition: all 0.2s;
    }

    .map-marker:hover {
      filter: brightness(1.1);
    }

    .marker-cluster {
      cursor: pointer;
      transition: all 0.2s;
    }

    .marker-cluster:hover {
      transform: scale(1.1);
      opacity: 1 !important;
    }

    .cluster-text {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      text-shadow: 1px 1px 1px rgba(0, 0, 0, 0.5);
      pointer-events: none;
      user-select: none;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
    }

    .cluster-group {
      cursor: pointer;
    }

    .cluster-tooltip {
      border: 1px solid #444;
    }

    .cluster-tooltip::-webkit-scrollbar {
      width: 6px;
    }

    .cluster-tooltip::-webkit-scrollbar-track {
      background: rgba(255, 255, 255, 0.1);
      border-radius: 3px;
    }

    .cluster-tooltip::-webkit-scrollbar-thumb {
      background: rgba(255, 255, 255, 0.3);
      border-radius: 3px;
    }

    .cluster-tooltip::-webkit-scrollbar-thumb:hover {
      background: rgba(255, 255, 255, 0.5);
    }

    .country {
      cursor: pointer;
      transition: fill 0.2s;
    }

    .country:hover {
      fill: #d4f1d4 !important;
      stroke: #4caf50;
      stroke-width: 1;
    }

    .marker-tooltip {
      position: absolute;
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 0.5rem;
      border-radius: 4px;
      font-size: 0.8rem;
      pointer-events: none;
      z-index: 1000;
      max-width: 200px;
    }

    @media (max-width: 768px) {
      .header-title {
        flex-direction: column;
        align-items: flex-start;
      }

      .summary-stats {
        flex-wrap: wrap;
      }

      h1 {
        font-size: 2rem;
      }

      .controls-section {
        flex-direction: column;
        align-items: stretch;
      }

      .map-container {
        height: 400px;
        margin: 1rem;
      }

      .table-container {
        margin: 1rem;
      }

      .navigation-links {
        flex-direction: column;
        gap: 1rem;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header-section">
      <div class="header-title">
        <div class="title-section">
          <img src="https://galaxyproject.org/images/galaxy-logos/galaxy_project_logo_square_no_text_trans.png" alt="Galaxy Project Logo" class="galaxy-logo">
          <div>
            <h1>Galaxy Instance Map</h1>
            <div class="subtitle">Geographic distribution of Galaxy instances worldwide</div>
          </div>
        </div>
        
        <div id="summary-stats" class="summary-stats" style="display: none;">
          <div class="stat-box">
            <div class="stat-number" id="total-servers">0</div>
            <div>Total Instances</div>
          </div>
          <div class="stat-box">
            <div class="stat-number" id="countries-count">0</div>
            <div>Countries</div>
          </div>
        </div>
      </div>
      
      <div class="search-container">
        <input type="text" id="search-input" class="search-input" placeholder="🔍 Search instances by name, region, or country...">
      </div>
    </div>

    <div class="controls-section">
      <div class="view-toggle">
        <button id="map-view" class="active">
          <i class="fas fa-map"></i> Map View
        </button>
        <button id="table-view">
          <i class="fas fa-table"></i> Table View
        </button>
      </div>
      
      <button id="refresh-button" class="refresh-btn">
        <i class="fas fa-sync-alt"></i> Refresh Data
      </button>
      
      <button id="export-button" class="export-btn">
        <i class="fas fa-file-csv"></i> Export CSV
      </button>
      
      <button id="geolocate-button" class="refresh-btn">
        <i class="fas fa-map-marked-alt"></i> Refresh Locations
      </button>
      
      <button onclick="window.location.href='index.html'" class="refresh-btn">
        <i class="fas fa-info-circle"></i> Display Status
      </button>
    </div>

    <div id="map-container" class="map-container">
      <svg id="world-map"></svg>
    </div>

    <!-- Cluster details container shown beneath the map -->
    <div id="cluster-details-container" class="cluster-details-container" style="display: none;">
      <div class="cluster-details-header">
        <i class="fas fa-layer-group"></i>
        <span id="cluster-title">Cluster Details</span>
        <button id="close-cluster-details" class="close-btn">
          <i class="fas fa-times"></i>
        </button>
      </div>
      <div id="cluster-details-content">
        <p>Hover over a cluster marker to see instance details</p>
      </div>
    </div>

    <div id="table-container" class="table-container" style="display: none;">
      <div class="table-header">
        <i class="fas fa-globe"></i>
        Galaxy Instances by Location
      </div>
      <div style="overflow-x: auto; max-height: 600px; overflow-y: auto;">
        <table id="location-table">
          <thead>
            <tr>
              <th>Instance</th>
              <th>Tier</th>
              <th>Region</th>
              <th>Description</th>
              <th>Location</th>
              <th>Coordinates</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
    </div>

    <div id="status" class="status-loading">
      Loading Galaxy instance data...
    </div>

    <div class="navigation-links">
      <a href="index.html">
        <i class="fas fa-table"></i> Main Instance Tracker
      </a>
      <a href="https://docs.google.com/spreadsheets/d/1HSpJ7vOxfnYSjfFm1vs528eydh1gVU40rKR6-1TCeCo/edit#gid=0" target="_blank">
        <i class="fas fa-file-spreadsheet"></i> Source Spreadsheet
      </a>
      <a href="https://github.com/mschatz/gxyservers" target="_blank">
        <i class="fab fa-github"></i> GitHub Repository
      </a>
      <a href="https://gxy.io/kui" target="_blank">
        <i class="fas fa-rocket"></i> Galaxy KUI
      </a>
    </div>
  </div>

  <script>
    // Same Google Sheets configuration as index.html
    const sheetId = '1HSpJ7vOxfnYSjfFm1vs528eydh1gVU40rKR6-1TCeCo';
    const sheetUrl = `https://docs.google.com/spreadsheets/d/${sheetId}/export?format=csv&gid=0`;

    // Same set of CORS proxies used in index.html
    const corsProxies = [
      'https://corsproxy.io/?url=',
      'https://api.codetabs.com/v1/proxy?quest=',
      'https://cors.bridged.cc/',
      'https://api.allorigins.win/raw?url='
    ];

    // Helper to fetch a URL through the proxies with a timeout
    async function fetchWithProxies(url, options = {}, timeout = 15000, maxRetries = 1) {
      for (let proxyIndex = 0; proxyIndex < corsProxies.length; proxyIndex++) {
        const proxy = corsProxies[proxyIndex];
        const proxiedUrl = `${proxy}${encodeURIComponent(url)}`;
        for (let attempt = 0; attempt <= maxRetries; attempt++) {
          const controller = new AbortController();
          const timer = setTimeout(() => controller.abort(), timeout);
          try {
            const response = await fetch(proxiedUrl, { ...options, signal: controller.signal });
            clearTimeout(timer);
            if (response.ok) {
              return response;
            }
          } catch (err) {
            clearTimeout(timer);
          }
        }
      }
      throw new Error('All proxies failed for ' + url);
    }

    // Global variables
    let currentData = [];
    let filteredData = [];
    let currentView = 'map';
    let svg, projection, path, worldData, zoom;

    // D3.js map variables
    const width = 1000;
    const height = 600;

    // Geolocation cache for servers or city lookups
    const GEO_CACHE_KEY = 'galaxyServerGeoCache';
    const GEO_CACHE_DURATION = 30 * 24 * 60 * 60 * 1000; // 30 days

    // Geolocation functions
    function saveGeoToCache(serverUrl, geoData) {
      try {
        const cache = getGeoCache();
        cache[serverUrl] = {
          data: geoData,
          timestamp: Date.now()
        };
        localStorage.setItem(GEO_CACHE_KEY, JSON.stringify(cache));
      } catch (error) {
        console.log('Error saving geolocation to cache:', error);
      }
    }

    function getGeoFromCache(serverUrl) {
      try {
        const cache = getGeoCache();
        const cached = cache[serverUrl];
        
        if (cached && (Date.now() - cached.timestamp < GEO_CACHE_DURATION)) {
          return cached.data;
        }
        
        // Remove expired cache entry
        if (cached) {
          delete cache[serverUrl];
          localStorage.setItem(GEO_CACHE_KEY, JSON.stringify(cache));
        }
        
        return null;
      } catch (error) {
        console.log('Error reading geolocation from cache:', error);
        return null;
      }
    }

    function getGeoCache() {
      try {
        const cache = localStorage.getItem(GEO_CACHE_KEY);
        return cache ? JSON.parse(cache) : {};
      } catch (error) {
        return {};
      }
    }

    function clearGeoCache() {
      try {
        localStorage.removeItem(GEO_CACHE_KEY);
        console.log('Geolocation cache cleared');
      } catch (error) {
        console.log('Error clearing geolocation cache:', error);
      }
    }

    // City GPS coordinates mapping
    const cityCoordinates = {
      "Austin, TX, USA": { lat: 30.2672, lng: -97.7431 },
      "Freiburg, Germany": { lat: 47.9990, lng: 7.8421 },
      "Melbourne, Australia": { lat: -37.8136, lng: 144.9631 },
      "Lyon, France": { lat: 45.7640, lng: 4.8357 },
      "Leuven, Belgium": { lat: 50.8798, lng: 4.7005 },
      "Toronto, Canada": { lat: 43.6510, lng: -79.3470 },
      "Brno, Czechia": { lat: 49.1951, lng: 16.6068 },
      "Bologna, Italy": { lat: 44.4949, lng: 11.3426 },
      "Bangalore, India": { lat: 12.9716, lng: 77.5946 },
      "Oslo, Norway": { lat: 59.9139, lng: 10.7522 },
      "Barcelona, Spain": { lat: 41.3851, lng: 2.1734 },
      "Cape Town, South Africa": { lat: -33.9249, lng: 18.4241 },
      "Rotterdam, Netherlands": { lat: 51.9225, lng: 4.47917 },
      "Minneapolis, MN, USA": { lat: 44.9778, lng: -93.2650 },
      "Tampa, FL, USA": { lat: 27.9506, lng: -82.4572 },
      "Hong Kong, China": { lat: 22.3193, lng: 114.1694 },
      "Clermont-Ferrand, France": { lat: 45.7772, lng: 3.0870 },
      "Ghent, Belgium": { lat: 51.0543, lng: 3.7174 },
      "Paris, France": { lat: 48.8566, lng: 2.3522 },
      "Angers, France": { lat: 47.4784, lng: -0.5632 },
      "Bari, Italy": { lat: 41.1171, lng: 16.8719 },
      "Montpellier, France": { lat: 43.6108, lng: 3.8767 },
      "Bolzano, Italy": { lat: 46.4983, lng: 11.3548 },
      "Jouy-en-Josas, France": { lat: 48.7630, lng: 2.1699 },
      "Laurel, MD, USA": { lat: 39.0993, lng: -76.8483 },
      "Knoxville, TN, USA": { lat: 35.9606, lng: -83.9207 },
      "Würzburg, Germany": { lat: 49.7913, lng: 9.9534 },
      "Bethesda, MD, USA": { lat: 38.9847, lng: -77.0947 },
      "Madrid, Spain": { lat: 40.4168, lng: -3.7038 },
      "Gatersleben, Germany": { lat: 51.8214, lng: 11.2866 },
      "Beirut, Lebanon": { lat: 33.8938, lng: 35.5018 },
      "Zurich, Switzerland": { lat: 47.3769, lng: 8.5417 },
      "Manchester, United Kingdom": { lat: 53.4808, lng: -2.2426 },
      "Athena, Greece": { lat: 37.9838, lng: 23.7275 },
      "Braga, Portugal": { lat: 41.5454, lng: -8.4265 },
      "Bielefeld, Germany": { lat: 52.0302, lng: 8.5325 },
      "Farmington, CT, USA": { lat: 41.7198, lng: -72.8320 },
      "Los Baños, Philippines": { lat: 14.1789, lng: 121.2258 },
      "Penn State, PA, USA": { lat: 40.7982, lng: -77.8599 },
      "Toulouse, France": { lat: 43.6047, lng: 1.4442 },
      "Boston, MA, USA": { lat: 42.3601, lng: -71.0589 },
      "Birmingham, United Kingdom": { lat: 52.4862, lng: -1.8904 },
      "Uppsala, Sweden": { lat: 59.8586, lng: 17.6389 },
      "Utrecht, Netherlands": { lat: 52.0907, lng: 5.1214 },
      "Philadelphia, PA, USA": { lat: 39.9526, lng: -75.1652 }
    };

    // Mapping countries to their flag emojis
    const countryToFlag = {
      "USA": "🇺🇸",
      "Germany": "🇩🇪",
      "Australia": "🇦🇺",
      "France": "🇫🇷",
      "Belgium": "🇧🇪",
      "Canada": "🇨🇦",
      "Czechia": "🇨🇿",
      "Italy": "🇮🇹",
      "India": "🇮🇳",
      "Norway": "🇳🇴",
      "Spain": "🇪🇸",
      "South Africa": "🇿🇦",
      "Netherlands": "🇳🇱",
      "China": "🇨🇳",
      "Lebanon": "🇱🇧",
      "Switzerland": "🇨🇭",
      "United Kingdom": "🇬🇧",
      "Greece": "🇬🇷",
      "Portugal": "🇵🇹",
      "Philippines": "🇵🇭",
      "Sweden": "🇸🇪"
    };

    // Function to get coordinates by city name
    function getCoordinatesByCityName(cityName) {
      cityName = cityName.toLowerCase().trim();

      console.log(`Searching for coordinates for city: ${cityName}`);

      for (const cityKey in cityCoordinates) {
        const cityLower = cityKey.toLowerCase();
        if (cityLower === cityName || cityLower.startsWith(cityName + ',')) {
          console.log(`Found coordinates for city: ${cityName}`);
          return cityCoordinates[cityKey];
        }
      }

      console.log(`No coordinates found for city: ${cityName}`);
      return null; // Return null if not found
    }

    // Function to get country flag emoji by country name
    function getCountryFlag(countryName) {
      return countryToFlag[countryName] || '🏳️';
    }

    // Function to get geolocation data for a server URL
    async function getServerGeolocation(url, forceRefresh = false) {
      if (!url || url.trim() === '') {
        return { 
          country: 'Unknown', 
          city: 'Unknown', 
          latitude: null, 
          longitude: null, 
          flag: '🏳️' 
        };
      }

      // Clean URL for consistency
      let cleanUrl = url.trim();
      if (!cleanUrl.startsWith('http://') && !cleanUrl.startsWith('https://')) {
        cleanUrl = 'https://' + cleanUrl;
      }

      try {
        const urlObj = new URL(cleanUrl);
        const hostname = urlObj.hostname.toLowerCase();
        const cacheKey = `host|${hostname}`;

        // Check cache first
        if (!forceRefresh) {
          const cachedData = getGeoFromCache(cacheKey);
          if (cachedData) {
            console.log(`[GeoCache] HIT for ${cacheKey}`);
            return cachedData;
          } else {
            console.log(`[GeoCache] MISS for ${cacheKey}`);
          }
        }

        // Try multiple geolocation APIs
        const geoApis = [
          `https://ipapi.co/${hostname}/json/`,
          `https://api.ipgeolocation.io/ipgeo?apiKey=free&hostname=${hostname}`,
          `https://freegeoip.app/json/${hostname}`,
          `https://ipinfo.io/${hostname}/json`
        ];
        
        for (const apiUrl of geoApis) {
          try {
            console.log(`Trying geolocation API for ${hostname}: ${apiUrl}`);
            const response = await fetchWithProxies(apiUrl);
            
            if (response.ok) {
              const geoData = await response.json();
              console.log(`API response for ${hostname}:`, geoData);
              
              // Handle different API response formats
              let result = null;
              
              // ipapi.co format
              if (geoData && !geoData.error && geoData.country_name) {
                result = {
                  country: geoData.country_name,
                  city: geoData.city || geoData.region || 'Unknown',
                  latitude: parseFloat(geoData.latitude),
                  longitude: parseFloat(geoData.longitude),
                  flag: getCountryFlag(geoData.country_code),
                  countryCode: geoData.country_code
                };
              }
              // ipgeolocation.io format
              else if (geoData && geoData.country_name) {
                result = {
                  country: geoData.country_name,
                  city: geoData.city || geoData.state_prov || 'Unknown',
                  latitude: parseFloat(geoData.latitude),
                  longitude: parseFloat(geoData.longitude),
                  flag: getCountryFlag(geoData.country_code2),
                  countryCode: geoData.country_code2
                };
              }
              // freegeoip.app format
              else if (geoData && geoData.country_name) {
                result = {
                  country: geoData.country_name,
                  city: geoData.city || geoData.region_name || 'Unknown',
                  latitude: parseFloat(geoData.latitude),
                  longitude: parseFloat(geoData.longitude),
                  flag: getCountryFlag(geoData.country_code),
                  countryCode: geoData.country_code
                };
              }
              // ipinfo.io format
              else if (geoData && geoData.country) {
                result = {
                  country: geoData.country,
                  city: geoData.city || geoData.region || 'Unknown',
                  latitude: parseFloat(geoData.loc ? geoData.loc.split(',')[0] : null),
                  longitude: parseFloat(geoData.loc ? geoData.loc.split(',')[1] : null),
                  flag: getCountryFlag(geoData.country),
                  countryCode: geoData.country
                };
              }
              
              if (result && result.latitude && result.longitude && !isNaN(result.latitude) && !isNaN(result.longitude)) {
                console.log(`Successfully geolocated ${hostname}:`, result);
                saveGeoToCache(cacheKey, result);
                return result;
              }
            }
          } catch (error) {
            console.log(`Geolocation API ${apiUrl} failed for ${hostname}:`, error);
            continue;
          }
        }

        // All APIs failed, try hostname-based guessing
        console.log(`All geolocation APIs failed for ${hostname}, falling back to hostname patterns`);
        const locationGuess = guessLocationFromHostname(hostname);
        saveGeoToCache(hostname, locationGuess);
        return locationGuess;

      } catch (error) {
        console.log(`Error processing URL ${url}:`, error);
        return { 
          country: 'Unknown', 
          city: 'Unknown', 
          latitude: null, 
          longitude: null, 
          flag: '🏳️' 
        };
      }
    }
    

    // Function to guess location from hostname patterns
    function guessLocationFromHostname(hostname) {
      // Check for national subdomains first (e.g., india.usegalaxy.eu, africa.usegalaxy.eu)
      const nationalPatterns = {
        'india.usegalaxy.eu': { country: 'India', countryCode: 'IN', flag: '🇮🇳', lat: 20.5937, lng: 78.9629, city: 'New Delhi' },
        'africa.usegalaxy.eu': { country: 'South Africa', countryCode: 'ZA', flag: '🇿🇦', lat: -30.5595, lng: 22.9375, city: 'Cape Town' },
        'covid19.usegalaxy.eu': { country: 'Germany', countryCode: 'DE', flag: '🇩🇪', lat: 48.0, lng: 7.8, city: 'Freiburg' },
        'annotation.usegalaxy.eu': { country: 'Germany', countryCode: 'DE', flag: '🇩🇪', lat: 48.0, lng: 7.8, city: 'Freiburg' },
        'climate.usegalaxy.eu': { country: 'Germany', countryCode: 'DE', flag: '🇩🇪', lat: 48.0, lng: 7.8, city: 'Freiburg' },
        'metagenomics.usegalaxy.eu': { country: 'Germany', countryCode: 'DE', flag: '🇩🇪', lat: 48.0, lng: 7.8, city: 'Freiburg' },
        'plants.usegalaxy.eu': { country: 'Germany', countryCode: 'DE', flag: '🇩🇪', lat: 48.0, lng: 7.8, city: 'Freiburg' },
        'live.usegalaxy.eu': { country: 'Germany', countryCode: 'DE', flag: '🇩🇪', lat: 48.0, lng: 7.8, city: 'Freiburg' },
        'ml.usegalaxy.eu': { country: 'Germany', countryCode: 'DE', flag: '🇩🇪', lat: 48.0, lng: 7.8, city: 'Freiburg' },
        'imaging.usegalaxy.eu': { country: 'Germany', countryCode: 'DE', flag: '🇩🇪', lat: 48.0, lng: 7.8, city: 'Freiburg' },
        'proteomics.usegalaxy.eu': { country: 'Germany', countryCode: 'DE', flag: '🇩🇪', lat: 48.0, lng: 7.8, city: 'Freiburg' },
        'ecology.usegalaxy.eu': { country: 'Germany', countryCode: 'DE', flag: '🇩🇪', lat: 48.0, lng: 7.8, city: 'Freiburg' },
        'metabolomics.usegalaxy.eu': { country: 'Germany', countryCode: 'DE', flag: '🇩🇪', lat: 48.0, lng: 7.8, city: 'Freiburg' },
        'microbiome.usegalaxy.eu': { country: 'Germany', countryCode: 'DE', flag: '🇩🇪', lat: 48.0, lng: 7.8, city: 'Freiburg' },
        // Add other potential national instances
        'canada.usegalaxy.org': { country: 'Canada', countryCode: 'CA', flag: '🇨🇦', lat: 45.4215, lng: -75.6972, city: 'Ottawa' },
        'brazil.usegalaxy.org': { country: 'Brazil', countryCode: 'BR', flag: '🇧🇷', lat: -15.7942, lng: -47.8822, city: 'Brasília' },
        'mexico.usegalaxy.org': { country: 'Mexico', countryCode: 'MX', flag: '🇲🇽', lat: 19.4326, lng: -99.1332, city: 'Mexico City' },
        'japan.usegalaxy.org': { country: 'Japan', countryCode: 'JP', flag: '🇯🇵', lat: 35.6762, lng: 139.6503, city: 'Tokyo' },
        'korea.usegalaxy.org': { country: 'South Korea', countryCode: 'KR', flag: '🇰🇷', lat: 37.5665, lng: 126.9780, city: 'Seoul' },
        'china.usegalaxy.org': { country: 'China', countryCode: 'CN', flag: '🇨🇳', lat: 39.9042, lng: 116.4074, city: 'Beijing' }
      };

      // Check for national patterns first
      for (const [pattern, location] of Object.entries(nationalPatterns)) {
        if (hostname.includes(pattern)) {
          return {
            country: location.country,
            city: location.city,
            latitude: location.lat,
            longitude: location.lng,
            flag: location.flag,
            countryCode: location.countryCode
          };
        }
      }

      // Check for specific university/institution patterns
      const institutionPatterns = {
        'hku.hk': { country: 'Hong Kong', countryCode: 'HK', flag: '🇭🇰', lat: 22.2830, lng: 114.1371, city: 'Hong Kong' },
        'pasteur.fr': { country: 'France', countryCode: 'FR', flag: '🇫🇷', lat: 48.8566, lng: 2.3522, city: 'Paris' },
        'galaxy-synbiocad.org': { country: 'France', countryCode: 'FR', flag: '🇫🇷', lat: 48.76, lng: 2.17, city: 'Paris' },
        'inrae.fr': { country: 'France', countryCode: 'FR', flag: '🇫🇷', lat: 48.8566, lng: 2.3522, city: 'Paris' },
        'uni-freiburg.de': { country: 'Germany', countryCode: 'DE', flag: '🇩🇪', lat: 48.0, lng: 7.8, city: 'Freiburg' },
        'moffitt.org': { country: 'United States', countryCode: 'US', flag: '🇺🇸', lat: 27.9506, lng: -82.4572, city: 'Tampa, FL' },
        'usegalaxy.org.au': { country: 'Australia', countryCode: 'AU', flag: '🇦🇺', lat: -37.8136, lng: 144.9631, city: 'Melbourne' },
        'usegalaxy.org': { country: 'United States', countryCode: 'US', flag: '🇺🇸', lat: 30.2672, lng: -97.7431, city: 'Austin, TX' },
        'utk.edu': { country: 'United States', countryCode: 'US', flag: '🇺🇸', lat: 35.9653, lng: -83.9233, city: 'Knoxville, TN' },
        'usegalaxy.eu': { country: 'Germany', countryCode: 'DE', flag: '🇩🇪', lat: 48.0, lng: 7.8, city: 'Freiburg' },
        'galaxyproject.org': { country: 'United States', countryCode: 'US', flag: '🇺🇸', lat: 30.2672, lng: -97.7431, city: 'Austin, TX' },
        'genome.edu.au': { country: 'Australia', countryCode: 'AU', flag: '🇦🇺', lat: -37.8136, lng: 144.9631, city: 'Melbourne' },
        // Additional institutional patterns based on console log
        'halogen-bonding.org': { country: 'Germany', countryCode: 'DE', flag: '🇩🇪', lat: 48.5227, lng: 9.0522, city: 'Tübingen' },
        'uni-tuebingen.de': { country: 'Germany', countryCode: 'DE', flag: '🇩🇪', lat: 48.5227, lng: 9.0522, city: 'Tübingen' },
        'oqtans.org': { country: 'Switzerland', countryCode: 'CH', flag: '🇨🇭', lat: 47.3769, lng: 8.5417, city: 'Zürich' },
        'ethz.ch': { country: 'Switzerland', countryCode: 'CH', flag: '🇨🇭', lat: 47.3769, lng: 8.5417, city: 'Zürich' },
        'palfinder.ls.manchester.ac.uk': { country: 'United Kingdom', countryCode: 'GB', flag: '🇬🇧', lat: 53.4668, lng: -2.2339, city: 'Manchester' },
        'manchester.ac.uk': { country: 'United Kingdom', countryCode: 'GB', flag: '🇬🇧', lat: 53.4668, lng: -2.2339, city: 'Manchester' },
        'climb.ac.uk': { country: 'United Kingdom', countryCode: 'GB', flag: '🇬🇧', lat: 52.6367, lng: 1.2966, city: 'Norwich' },
        'tsl.ac.uk': { country: 'United Kingdom', countryCode: 'GB', flag: '🇬🇧', lat: 52.6367, lng: 1.2966, city: 'Norwich' },
        'hyperbrowser.uio.no': { country: 'Norway', countryCode: 'NO', flag: '🇳🇴', lat: 59.9139, lng: 10.7522, city: 'Oslo' },
        'uio.no': { country: 'Norway', countryCode: 'NO', flag: '🇳🇴', lat: 59.9139, lng: 10.7522, city: 'Oslo' },
        'coloc-stats.no': { country: 'Norway', countryCode: 'NO', flag: '🇳🇴', lat: 59.9139, lng: 10.7522, city: 'Oslo' },
        'gaslini.org': { country: 'Italy', countryCode: 'IT', flag: '🇮🇹', lat: 44.4056, lng: 8.9463, city: 'Genoa' },
        'eurac.edu': { country: 'Italy', countryCode: 'IT', flag: '🇮🇹', lat: 46.5, lng: 11.35, city: 'Bolzano' },
        'corgat.cloud.ba.infn.it': { country: 'Italy', countryCode: 'IT', flag: '🇮🇹', lat: 41.1171, lng: 16.8719, city: 'Bari' },
        'infn.it': { country: 'Italy', countryCode: 'IT', flag: '🇮🇹', lat: 41.9028, lng: 12.4964, city: 'Rome' },
        'biobix.be': { country: 'Belgium', countryCode: 'BE', flag: '🇧🇪', lat: 51.0259, lng: 3.7078, city: 'Ghent' },
        'ugent.be': { country: 'Belgium', countryCode: 'BE', flag: '🇧🇪', lat: 51.0259, lng: 3.7078, city: 'Ghent' },
        'sb-roscoff.fr': { country: 'France', countryCode: 'FR', flag: '🇫🇷', lat: 48.7263, lng: -3.9886, city: 'Roscoff' },
        'workflow4metabolomics.org': { country: 'France', countryCode: 'FR', flag: '🇫🇷', lat: 48.8566, lng: 2.3522, city: 'Paris' },
        'migale.inrae.fr': { country: 'France', countryCode: 'FR', flag: '🇫🇷', lat: 48.8008, lng: 2.1342, city: 'Jouy-en-Josas' },
        'cfbp.inrae.fr': { country: 'France', countryCode: 'FR', flag: '🇫🇷', lat: 49.0875, lng: 0.2308, city: 'Angers' },
        'ipk-gatersleben.de': { country: 'Germany', countryCode: 'DE', flag: '🇩🇪', lat: 51.8133, lng: 11.2834, city: 'Gatersleben' },
        'cpgr.apc.univ-paris7.fr': { country: 'France', countryCode: 'FR', flag: '🇫🇷', lat: 48.8566, lng: 2.3522, city: 'Paris' },
        'sciencespo.fr': { country: 'France', countryCode: 'FR', flag: '🇫🇷', lat: 48.8566, lng: 2.3522, city: 'Paris' },
        'snic.se': { country: 'Sweden', countryCode: 'SE', flag: '🇸🇪', lat: 59.3344, lng: 18.0632, city: 'Stockholm' },
        'surf.nl': { country: 'Netherlands', countryCode: 'NL', flag: '🇳🇱', lat: 52.0907, lng: 5.1214, city: 'Utrecht' },
        'nectar.org.au': { country: 'Australia', countryCode: 'AU', flag: '🇦🇺', lat: -37.8136, lng: 144.9631, city: 'Melbourne' },
        'laniakea-elixir-it.github.io': { country: 'Italy', countryCode: 'IT', flag: '🇮🇹', lat: 38.1112, lng: 13.3524, city: 'Palermo' },
        'unipa.it': { country: 'Italy', countryCode: 'IT', flag: '🇮🇹', lat: 38.1112, lng: 13.3524, city: 'Palermo' },
        'francegrille.eu': { country: 'France', countryCode: 'FR', flag: '🇫🇷', lat: 48.8566, lng: 2.3522, city: 'Paris' },
        'vm-chemflow-francegrille.eu': { country: 'France', countryCode: 'FR', flag: '🇫🇷', lat: 48.8566, lng: 2.3522, city: 'Paris' }
      };

      // Check for specific institution patterns
      for (const [pattern, location] of Object.entries(institutionPatterns)) {
        if (hostname.includes(pattern)) {
          return {
            country: location.country,
            city: location.city || 'Unknown',
            latitude: location.lat,
            longitude: location.lng,
            flag: location.flag,
            countryCode: location.countryCode
          };
        }
      }

      // Check TLD patterns
      const patterns = {
        '.au': { country: 'Australia', countryCode: 'AU', flag: '🇦🇺', lat: -25.2744, lng: 133.7751 },
        '.uk': { country: 'United Kingdom', countryCode: 'GB', flag: '🇬🇧', lat: 55.3781, lng: -3.4360 },
        '.ca': { country: 'Canada', countryCode: 'CA', flag: '🇨🇦', lat: 56.1304, lng: -106.3468 },
        '.de': { country: 'Germany', countryCode: 'DE', flag: '🇩🇪', lat: 51.1657, lng: 10.4515 },
        '.fr': { country: 'France', countryCode: 'FR', flag: '🇫🇷', lat: 46.2276, lng: 2.2137 },
        '.it': { country: 'Italy', countryCode: 'IT', flag: '🇮🇹', lat: 41.8719, lng: 12.5674 },
        '.es': { country: 'Spain', countryCode: 'ES', flag: '🇪🇸', lat: 40.4637, lng: -3.7492 },
        '.nl': { country: 'Netherlands', countryCode: 'NL', flag: '🇳🇱', lat: 52.1326, lng: 5.2913 },
        '.be': { country: 'Belgium', countryCode: 'BE', flag: '🇧🇪', lat: 50.5039, lng: 4.4699 },
        '.se': { country: 'Sweden', countryCode: 'SE', flag: '🇸🇪', lat: 60.1282, lng: 18.6435 },
        '.no': { country: 'Norway', countryCode: 'NO', flag: '🇳🇴', lat: 60.4720, lng: 8.4689 },
        '.dk': { country: 'Denmark', countryCode: 'DK', flag: '🇩🇰', lat: 56.2639, lng: 9.5018 },
        '.fi': { country: 'Finland', countryCode: 'FI', flag: '🇫🇮', lat: 61.9241, lng: 25.7482 },
        '.ch': { country: 'Switzerland', countryCode: 'CH', flag: '🇨🇭', lat: 46.8182, lng: 8.2275 },
        '.at': { country: 'Austria', countryCode: 'AT', flag: '🇦🇹', lat: 47.5162, lng: 14.5501 },
        '.cz': { country: 'Czech Republic', countryCode: 'CZ', flag: '🇨🇿', lat: 49.8175, lng: 15.4730 },
        '.pl': { country: 'Poland', countryCode: 'PL', flag: '🇵🇱', lat: 51.9194, lng: 19.1451 },
        '.in': { country: 'India', countryCode: 'IN', flag: '🇮🇳', lat: 20.5937, lng: 78.9629 },
        '.jp': { country: 'Japan', countryCode: 'JP', flag: '🇯🇵', lat: 36.2048, lng: 138.2529 },
        '.kr': { country: 'South Korea', countryCode: 'KR', flag: '🇰🇷', lat: 35.9078, lng: 127.7669 },
        '.cn': { country: 'China', countryCode: 'CN', flag: '🇨🇳', lat: 35.8617, lng: 104.1954 },
        '.br': { country: 'Brazil', countryCode: 'BR', flag: '🇧🇷', lat: -14.2350, lng: -51.9253 },
        '.mx': { country: 'Mexico', countryCode: 'MX', flag: '🇲🇽', lat: 23.6345, lng: -102.5528 },
        '.ar': { country: 'Argentina', countryCode: 'AR', flag: '🇦🇷', lat: -38.4161, lng: -63.6167 },
        '.za': { country: 'South Africa', countryCode: 'ZA', flag: '🇿🇦', lat: -30.5595, lng: 22.9375 },
        '.eu': { country: 'European Union', countryCode: 'EU', flag: '🇪🇺', lat: 50.8503, lng: 4.3517 },
        '.edu': { country: 'United States', countryCode: 'US', flag: '🇺🇸', lat: 39.8283, lng: -98.5795 },
        '.gov': { country: 'United States', countryCode: 'US', flag: '🇺🇸', lat: 39.8283, lng: -98.5795 },
        '.org': { country: 'United States', countryCode: 'US', flag: '🇺🇸', lat: 39.8283, lng: -98.5795 },
        '.com': { country: 'United States', countryCode: 'US', flag: '🇺🇸', lat: 39.8283, lng: -98.5795 }
      };

      for (const [tld, location] of Object.entries(patterns)) {
        if (hostname.endsWith(tld)) {
          return {
            country: location.country,
            city: 'Unknown',
            latitude: location.lat,
            longitude: location.lng,
            flag: location.flag,
            countryCode: location.countryCode
          };
        }
      }

      // Default to US for unknown domains
      return {
        country: 'United States',
        city: 'Unknown',
        latitude: 39.8283,
        longitude: -98.5795,
        flag: '🇺🇸',
        countryCode: 'US'
      };
    }

    // Geocode a city name (optionally using region for disambiguation)
    async function geocodeCityName(city, region = '', forceRefresh = false) {
      if (!city || city.trim() === '') {
        return {
          country: 'Unknown',
          city: 'Unknown',
          latitude: null,
          longitude: null,
          flag: '🏳️'
        };
      }

      const cacheKey = `city|${city}|${region}`.toLowerCase();

      if (!forceRefresh) {
        const cached = getGeoFromCache(cacheKey);
        if (cached) {
          console.log(`[GeoCache] HIT for ${cacheKey}`);
          return cached;
        } else {
          console.log(`[GeoCache] MISS for ${cacheKey}`);
        }
      }

      let query = city;
      if (region) {
        if (/united states|usa|us/i.test(region)) {
          query += ', USA';
        } else {
          query += `, ${region}`;
        }
      }

      const url = `https://nominatim.openstreetmap.org/search?format=json&addressdetails=1&q=${encodeURIComponent(query)}&limit=1`;

      try {
        const response = await fetchWithProxies(url, { headers: { 'Accept-Language': 'en' } });
        if (response.ok) {
          const results = await response.json();
          if (results && results.length > 0) {
            const r = results[0];
            const address = r.address || {};
            const result = {
              country: address.country || 'Unknown',
              city: address.city || address.town || address.village || city,
              latitude: parseFloat(r.lat),
              longitude: parseFloat(r.lon),
              flag: getCountryFlag((address.country_code || '').toUpperCase()),
              countryCode: (address.country_code || '').toUpperCase()
            };

            saveGeoToCache(cacheKey, result);
            return result;
          }
        }
      } catch (error) {
        console.log('Error geocoding city:', city, error);
      }

      return {
        country: 'Unknown',
        city: 'Unknown',
        latitude: null,
        longitude: null,
        flag: '🏳️'
      };
    }

    // Function to get country flag emoji from country code
    function getCountryFlag(countryCode) {
      if (!countryCode || countryCode.length !== 2) return '🏳️';
      
      const flagMap = {
        'AU': '🇦🇺', 'UK': '🇬🇧', 'GB': '🇬🇧', 'CA': '🇨🇦', 'DE': '🇩🇪',
        'FR': '🇫🇷', 'IT': '🇮🇹', 'ES': '🇪🇸', 'NL': '🇳🇱', 'BE': '🇧🇪',
        'SE': '🇸🇪', 'NO': '🇳🇴', 'DK': '🇩🇰', 'FI': '🇫🇮', 'CH': '🇨🇭',
        'AT': '🇦🇹', 'CZ': '🇨🇿', 'PL': '🇵🇱', 'IN': '🇮🇳', 'JP': '🇯🇵',
        'KR': '🇰🇷', 'CN': '🇨🇳', 'BR': '🇧🇷', 'MX': '🇲🇽', 'AR': '🇦🇷',
        'ZA': '🇿🇦', 'US': '🇺🇸'
      };
      
      return flagMap[countryCode.toUpperCase()] || '🏳️';
    }

    // Function to get status icon (full version from index.html)
    function getStatusIcon(version, toolCount, tier = null, serverReachable = null) {
      // Handle null, undefined, or empty version
      if (!version || version === '' || version === null || version === undefined) {
        return { icon: '⏳', class: 'unknown', tooltip: 'Status unknown - loading or no data available' };
      }
      
      // Convert to string and trim for consistent comparison
      const versionStr = String(version).trim();
      const toolCountStr = String(toolCount || '').trim();
      const tierStr = String(tier || '').trim();
      
      // Special handling for Tier 5 (Integrated Deployment) instances
      // For Tier 5, if the site is reachable but API doesn't respond, consider it online
      if (tierStr === '5') {
        // If the instance is reachable (website responds) even with API errors, it's online
        if (serverReachable === true) {
          // Check if we have API errors but the site itself is reachable
          if (versionStr === 'API Error' || versionStr === 'Unknown' || versionStr === 'Error' ||
              versionStr === 'CORS Blocked' || toolCountStr === 'API Error') {
            return { icon: '🟢', class: 'online', tooltip: 'Integrated platform is online (Galaxy API may not be directly accessible)' };
          }
        }
        
        // If explicitly marked as unreachable or has DNS/network errors, it's offline
        if (versionStr.includes('ERR_NAME_NOT_RESOLVED') || versionStr.includes('ENOTFOUND') || 
            versionStr.includes('SERVER_UNREACHABLE') || versionStr === 'DNS Error' || 
            versionStr === 'Offline') {
          return { icon: '🔴', class: 'offline', tooltip: 'Integrated platform is offline or unreachable' };
        }
      }
      
      // Handle specific status values that indicate the instance is completely offline/unreachable
      if (versionStr === 'Offline') {
        return { icon: '🔴', class: 'offline', tooltip: 'Instance is offline or unreachable' };
      }
      
      // Check if both version and tools indicate offline/unreachable
      if (toolCountStr === 'Offline' && (versionStr === 'Unknown' || versionStr === 'Error' || versionStr === 'API Error' || versionStr === 'Timeout')) {
        return { icon: '🔴', class: 'offline', tooltip: 'Instance is offline or unreachable' };
      }
      
      // Check if both version and tool count show API errors (completely unreachable)
      if (versionStr === 'API Error' && toolCountStr === 'API Error') {
        return { icon: '🔴', class: 'offline', tooltip: 'Instance is offline or unreachable (API calls failed)' };
      }
      
      // Check for explicit network/DNS errors that indicate instance is completely offline
      if (versionStr.includes('ERR_NAME_NOT_RESOLVED') || versionStr.includes('ENOTFOUND') || 
          versionStr.includes('SERVER_UNREACHABLE') || versionStr === 'DNS Error') {
        return { icon: '🔴', class: 'offline', tooltip: 'Instance is offline or unreachable (DNS/network error)' };
      }
      
      if (versionStr === 'No URL') {
        return { icon: '⚫', class: 'unknown', tooltip: 'No URL provided for this instance' };
      }
      if (versionStr === 'Local Mode') {
        return { icon: '🏠', class: 'unknown', tooltip: 'Running in local mode - limited functionality' };
      }
      
      // Handle loading states
      if (versionStr === 'Loading...' || versionStr === 'N/A') {
        return { icon: '⏳', class: 'unknown', tooltip: 'Status unknown or loading...' };
      }
      
      // Check if server is providing data (tools/genomes) even if version is problematic
      const hasToolData = toolCountStr && 
                         toolCountStr !== 'Loading...' && 
                         toolCountStr !== 'N/A' && 
                         toolCountStr !== 'Offline' && 
                         toolCountStr !== 'Error' && 
                         toolCountStr !== 'API Error' && 
                         toolCountStr !== 'Unknown' &&
                         toolCountStr !== 'No URL' &&
                         toolCountStr !== 'Local Mode' &&
                         (toolCountStr.includes('tools') || toolCountStr.includes('genomes') || /^\d+$/.test(toolCountStr));
      
      // If we can fetch tools/genomes but version is unknown, instance is online with issues
      if ((versionStr === 'Unknown' || versionStr === 'API Error' || versionStr === 'Error') && hasToolData) {
        return { icon: '🟡', class: 'issues', tooltip: 'Instance is online but has API issues (version unknown, but tools/genomes accessible)' };
      }
      
      // CORS blocked but instance appears online
      if (versionStr === 'CORS Blocked') {
        return { icon: '🟡', class: 'issues', tooltip: 'Instance appears online but API calls are blocked by browser CORS policy' };
      }
      
      // Instance requires authentication but is online
      if (versionStr.includes('Auth Required') || versionStr.includes('Authentication')) {
        return { icon: '🟡', class: 'issues', tooltip: 'Instance is online but requires authentication for API access' };
      }
      
      // Instance has issues but may be partially accessible (only if no tool data)
      if ((versionStr === 'Unknown' || versionStr === 'API Error' || versionStr === 'Error') && !hasToolData) {
        return { icon: '🟡', class: 'issues', tooltip: 'Instance status unknown due to API errors' };
      }
      
      // If version contains HTML (like version with start date), check for known patterns
      if (versionStr.includes('<br>') || versionStr.includes('<small>')) {
        // Extract the main version number before any HTML formatting
        const mainVersion = versionStr.split('<br>')[0].split('<small>')[0].trim();
        if (mainVersion && mainVersion !== '' && mainVersion !== 'Unknown' && mainVersion !== 'Error') {
          return { icon: '🟢', class: 'online', tooltip: 'Instance is online and responding' };
        } else {
          return { icon: '❓', class: 'unknown', tooltip: 'Instance status uncertain' };
        }
      }
      
      // Default case: if we have a meaningful version string that's not an error, instance is online
      if (versionStr && versionStr !== '' && versionStr !== 'Unknown' && versionStr !== 'Error') {
        return { icon: '🟢', class: 'online', tooltip: 'Instance is online and responding' };
      }
      
      // Final fallback for any unhandled cases
      return { icon: '⏳', class: 'unknown', tooltip: 'Status unknown' };
    }

    // Function to get tier icon and info
    function getTierInfo(tier) {
      const tierMap = {
        '1': { icon: '🌍', name: 'Global Instance', color: '#4caf50' },
        '2': { icon: '🏛️', name: 'National Instance', color: '#ff9800' },
        '3': { icon: '📍', name: 'Subdomain', color: '#2196f3' },
        '4': { icon: '🧪', name: 'Institutional', color: '#9c27b0' },
        '5': { icon: '🔗', name: 'Integrated Platform', color: '#607d8b' },
        '6': { icon: '⚙️', name: 'Development Instance', color: '#795548' }
      };
      
      return tierMap[tier] || { icon: '❓', name: 'Unknown Tier', color: '#999' };
    }

    // CSV parsing function (same as index.html)
    function parseCSV(text) {
      const lines = text.split('\n').filter(line => line.trim());
      if (lines.length === 0) return [];
      
      function parseCSVLine(line) {
        const result = [];
        let current = '';
        let inQuotes = false;
        
        for (let i = 0; i < line.length; i++) {
          const char = line[i];
          if (char === '"') {
            if (inQuotes && line[i + 1] === '"') {
              current += '"';
              i++;
            } else {
              inQuotes = !inQuotes;
            }
          } else if (char === ',' && !inQuotes) {
            result.push(current.trim());
            current = '';
          } else {
            current += char;
          }
        }
        result.push(current.trim());
        return result;
      }
      
      const headers = parseCSVLine(lines[0]);
      const data = [];
      
      for (let i = 1; i < lines.length; i++) {
        const values = parseCSVLine(lines[i]);
        
        const hasNonEmptyValue = values.some(value => value && value.trim() !== '');
        if (!hasNonEmptyValue) continue;
        
        const row = {};
        headers.forEach((header, index) => {
          row[header] = values[index] || '';
        });
        
        if (row['Tier'] === '###') break;
        if (row['Tier'] && row['Tier'].startsWith('#')) continue;
        
        data.push(row);
      }
      
      return data;
    }

    // Load spreadsheet data
    async function loadSpreadsheetData() {
      updateStatus('Loading Galaxy instance data...', 'loading');
      
      try {
        console.log('Fetching data from:', sheetUrl);
        
        // Add a timeout to the fetch
        const response = await fetchWithProxies(
          sheetUrl,
          {
            method: 'GET',
            headers: { 'Accept': 'text/csv' }
          },
          30000
        );
        console.log('Response status:', response.status, response.statusText);
        
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status} - ${response.statusText}`);
        }
        
        updateStatus('Processing spreadsheet data...', 'loading');
        const csvText = await response.text();
        console.log('CSV text length:', csvText.length);
        console.log('First 200 chars:', csvText.substring(0, 200));
        
        const data = parseCSV(csvText);
        console.log('Parsed data length:', data.length);
        
        if (data.length === 0) {
          throw new Error('No data found in spreadsheet');
        }
        
        console.log(`Loaded ${data.length} servers from spreadsheet`);
        currentData = data;
        filteredData = [...data];
        
        updateStatus(`Loaded ${data.length} instances. Getting server locations...`, 'loading');
        
        // Get geolocation data for all servers
        await geolocateAllServers();
        
        // Debug: Count how many servers have coordinates
        const serversWithCoords = currentData.filter(row => {
          const geo = row['GeoLocation'];
          return geo && geo.latitude !== null && geo.longitude !== null && 
                 !isNaN(geo.latitude) && !isNaN(geo.longitude);
        }).length;
        
        console.log(`${serversWithCoords} out of ${currentData.length} servers have valid coordinates`);
        
        updateSummaryStats();
        renderCurrentView();
        updateStatus(`Successfully loaded ${data.length} Galaxy instances with location data. ${serversWithCoords} servers mapped.`, 'success');
        
      } catch (error) {
        console.error('Error loading spreadsheet:', error);
        if (error.name === 'AbortError') {
          updateStatus(`Error: Request timed out after 30 seconds`, 'error');
        } else {
          updateStatus(`Error loading data: ${error.message}`, 'error');
        }
        
        // Try to show some fallback data or continue with empty data
        console.log('Continuing with empty data for testing...');
        currentData = [];
        filteredData = [];
        updateSummaryStats();
        renderCurrentView();
      }
    }

    // Geolocate all servers
    async function geolocateAllServers(forceRefresh = false) {
      let completedCount = 0;
      const totalCount = currentData.length;
      
      const promises = currentData.map(async (row, index) => {
        const url = row['URL'] || row['url'] || '';
        const city = row['city'] || row['City'] || '';
        const region = row['Region'] || row['region'] || '';

        try {
          let geoData = null;

          // 1. Try static city coordinates first
          if (city && city.trim()) {
            const staticCoords = getCoordinatesByCityName(city.trim());
            if (staticCoords && staticCoords.lat != null && staticCoords.lng != null) {
              geoData = {
                country: region || 'Unknown',
                city: city,
                latitude: staticCoords.lat,
                longitude: staticCoords.lng,
                flag: getCountryFlag(region || 'Unknown')
              };
            } else {
              // 2. Fallback to geocodeCityName
              geoData = await geocodeCityName(city.trim(), region, forceRefresh);
            }
          }

          // 3. Fallback to server geolocation if city lookup/geocode failed
          if (!geoData || geoData.latitude === null || geoData.longitude === null) {
            if (url && url.trim()) {
              geoData = await getServerGeolocation(url.trim(), forceRefresh);
            } else {
              geoData = {
                country: 'Unknown',
                city: 'Unknown',
                latitude: null,
                longitude: null,
                flag: '🏳️'
              };
            }
          }

          row['GeoLocation'] = geoData;
        } catch (error) {
          console.error(`Error geolocating ${url || city}:`, error);
          row['GeoLocation'] = {
            country: 'Unknown',
            city: 'Unknown',
            latitude: null,
            longitude: null,
            flag: '🏳️'
          };
        }
        
        completedCount++;
        if (completedCount % 5 === 0 || completedCount === totalCount) {
          updateStatus(`Getting locations... (${completedCount}/${totalCount} completed)`, 'loading');
        }
      });
      
      await Promise.all(promises);
    }

    // Update status message
    function updateStatus(message, type = 'loading') {
      const statusDiv = document.getElementById('status');
      statusDiv.textContent = message;
      statusDiv.className = `status-${type}`;
    }

    // Update summary statistics
    function updateSummaryStats() {
      const total = currentData.length;
      const countries = new Set(currentData.map(row => row['GeoLocation']?.country).filter(Boolean)).size;
      
      document.getElementById('total-servers').textContent = total;
      document.getElementById('countries-count').textContent = countries;
      document.getElementById('summary-stats').style.display = 'flex';
    }

    // Render the current view (map or table)
    function renderCurrentView() {
      if (currentView === 'map') {
        document.getElementById('map-container').style.display = 'block';
        document.getElementById('cluster-details-container').style.display = 'none';
        document.getElementById('table-container').style.display = 'none';
        
        // Initialize map if first time showing
        if (!svg) {
          initializeMap();
        } else {
          renderMap();
        }
      } else {
        document.getElementById('map-container').style.display = 'none';
        document.getElementById('cluster-details-container').style.display = 'none';
        document.getElementById('table-container').style.display = 'block';
        renderTable();
      }
    }

    // Initialize D3 map
    function initializeMap() {
      svg = d3.select("#world-map")
        .attr("width", width)
        .attr("height", height);

      // Set up projection (Natural Earth projection for better world view)
      projection = d3.geoNaturalEarth1()
        .scale(200)
        .translate([width / 2, height / 2]);

      path = d3.geoPath().projection(projection);

      // Add zoom behavior
      zoom = d3.zoom()
        .scaleExtent([0.5, 8])
        .on("zoom", (event) => {
          // Create a group for all map elements if it doesn't exist
          let mapGroup = svg.select(".map-group");
          if (mapGroup.empty()) {
            mapGroup = svg.append("g").attr("class", "map-group");
            // Move all existing elements to the group
            svg.selectAll("path, .map-marker, .marker-cluster, .cluster-text").each(function() {
              mapGroup.node().appendChild(this);
            });
          }
          
          // Apply transform to the entire group
          mapGroup.attr("transform", event.transform);
          
          // Scale markers to maintain good visibility at all zoom levels
          const zoomScale = event.transform.k;
          // More aggressive scaling that makes markers smaller when zoomed in
          // but still keeps them visible and clickable
          const markerScale = Math.max(0.3, 1 / (zoomScale * 0.8));
          
          // Update single markers with better scaling
          mapGroup.selectAll(".map-marker")
            .attr("r", 4 * markerScale)
            .attr("stroke-width", Math.max(0.3, 1 * markerScale));
          
          // Update single marker hit areas
          mapGroup.selectAll(".single-marker-hit-area")
            .attr("r", 8 * markerScale);
          
          // Update cluster markers and their stored radius data
          mapGroup.selectAll(".marker-cluster").each(function(d) {
            const clusterElement = d3.select(this);
            const parentGroup = d3.select(this.parentNode);
            const groupData = parentGroup.datum();
            
            if (groupData && groupData.radius) {
              // Scale the cluster based on original radius
              const scaledRadius = groupData.radius * markerScale;
              clusterElement
                .attr("r", scaledRadius)
                .attr("stroke-width", Math.max(0.3, 2 * markerScale));
              
              // Update hit area for clusters
              parentGroup.select(".cluster-hit-area")
                .attr("r", (groupData.radius + 5) * markerScale);
            }
          });
          
          // Update cluster text size
          mapGroup.selectAll(".cluster-text")
            .style("font-size", (10 * markerScale) + "px");
        });

      svg.call(zoom);

      // Load world data from Natural Earth
      loadWorldData();
    }

    // Load Natural Earth world data
    async function loadWorldData() {
      try {
        updateStatus('Loading world map data...', 'loading');
        
        // Use Natural Earth data via CDN (through CORS proxy)
        const worldResponse = await fetchWithProxies('https://cdn.jsdelivr.net/npm/world-atlas@2/countries-110m.json');
        const world = await worldResponse.json();
        worldData = world;
        
        // Create or get the map group
        let mapGroup = svg.select(".map-group");
        if (mapGroup.empty()) {
          mapGroup = svg.append("g").attr("class", "map-group");
        }
        
        // Add ocean background first
        mapGroup.insert("path", ":first-child")
          .datum({type: "Sphere"})
          .attr("class", "ocean")
          .attr("d", path);
        
        // Draw countries
        mapGroup.append("g")
          .attr("class", "countries")
          .selectAll("path")
          .data(topojson.feature(world, world.objects.countries).features)
          .enter().append("path")
          .attr("class", "country")
          .attr("d", path)
          .attr("fill", "#e8f5e8")
          .attr("stroke", "#b8d8b8")
          .attr("stroke-width", 0.5);

        console.log('World map loaded successfully');
        
        // Now render the markers if we have data
        if (currentData.length > 0) {
          renderMap();
        }
        
      } catch (error) {
        console.error('Error loading world data:', error);
        updateStatus('Error loading world map. Using fallback...', 'error');
        renderFallbackMap();
        
        // Still try to render markers with fallback map
        if (currentData.length > 0) {
          renderMap();
        }
      }
    }

    // Fallback map if Natural Earth data fails to load
    function renderFallbackMap() {
      // Create or get the map group
      let mapGroup = svg.select(".map-group");
      if (mapGroup.empty()) {
        mapGroup = svg.append("g").attr("class", "map-group");
      }
      
      mapGroup.append("rect")
        .attr("width", width)
        .attr("height", height)
        .attr("fill", "#e3f2fd")
        .attr("opacity", 0.3);
        
      // Simple continent outlines as fallback
      const continents = [
        // North America
        "M120,120 L300,100 L350,150 L320,200 L280,220 L200,210 L150,180 Z",
        // South America  
        "M250,250 L320,240 L350,300 L340,380 L300,400 L270,380 L240,320 Z",
        // Europe
        "M450,100 L520,95 L550,130 L530,150 L480,145 Z",
        // Africa
        "M480,180 L550,175 L570,250 L560,320 L520,340 L490,320 L470,250 Z",
        // Asia
        "M550,90 L750,85 L800,140 L780,200 L720,220 L650,200 L580,150 Z",
        // Australia
        "M720,300 L800,295 L820,320 L800,340 L740,335 Z"
      ];
      
      mapGroup.append("g")
        .attr("class", "continents")
        .selectAll("path")
        .data(continents)
        .enter().append("path")
        .attr("d", d => d)
        .attr("fill", "#e8f5e8")
        .attr("stroke", "#b8d8b8")
        .attr("stroke-width", 1);
        
      console.log('Fallback map rendered');
    }

    // Haversine formula to calculate distance between two lat/lng points in kilometers
    function calculateDistance(lat1, lng1, lat2, lng2) {
      const R = 6371; // Earth's radius in kilometers
      const dLat = (lat2 - lat1) * Math.PI / 180;
      const dLng = (lng2 - lng1) * Math.PI / 180;
      const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                Math.sin(dLng/2) * Math.sin(dLng/2);
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
      return R * c;
    }

    // Render the map with server markers
    function renderMap(data = null) {
      // Use provided data or fall back to global filteredData
      const dataToRender = data || filteredData;
      
      // Initialize map if not already done
      if (!svg) {
        initializeMap();
        return; // Map will be rendered after world data loads
      }
      
      // Get or create the map group
      let mapGroup = svg.select(".map-group");
      if (mapGroup.empty()) {
        mapGroup = svg.append("g").attr("class", "map-group");
      }
      
      // Clear existing markers
      mapGroup.selectAll(".map-marker").remove();
      mapGroup.selectAll(".marker-cluster").remove();
      mapGroup.selectAll(".cluster-text").remove();
      
      let markersAdded = 0;
      
      // Group instances by location (lat/lng with geographic distance tolerance for clustering)
      const locationGroups = new Map();
      
      dataToRender.forEach((row, index) => {
        const geoData = row['GeoLocation'];
        
        console.log(`Processing server ${row['Name']}: `, geoData);
        
        if (geoData && geoData.latitude !== null && geoData.longitude !== null && 
            !isNaN(geoData.latitude) && !isNaN(geoData.longitude)) {
          
          // Project lat/lng to screen coordinates using D3 projection
          const coords = projection([parseFloat(geoData.longitude), parseFloat(geoData.latitude)]);
          
          if (coords && coords[0] >= 0 && coords[0] <= width && coords[1] >= 0 && coords[1] <= height) {
            const lat = parseFloat(geoData.latitude);
            const lng = parseFloat(geoData.longitude);
            
            // Check if this location should be clustered with an existing group
            let clusteredWith = null;
            
            for (const [key, group] of locationGroups) {
              // Get the first instance's coordinates from this group
              const firstInstance = group.instances[0];
              const groupLat = parseFloat(firstInstance['GeoLocation'].latitude);
              const groupLng = parseFloat(firstInstance['GeoLocation'].longitude);
              
              // Calculate geographic distance in kilometers using Haversine formula
              const distance = calculateDistance(lat, lng, groupLat, groupLng);
              
              // Only cluster if within 50km (same city/metro area)
              if (distance < 50) {
                clusteredWith = key;
                break;
              }
            }
            
            if (clusteredWith) {
              // Add to existing cluster
              locationGroups.get(clusteredWith).instances.push({
                ...row,
                originalCoords: coords
              });
            } else {
              // Create new cluster
              const clusterKey = `${lat.toFixed(4)},${lng.toFixed(4)}`;
              locationGroups.set(clusterKey, {
                x: coords[0],
                y: coords[1],
                instances: [{
                  ...row,
                  originalCoords: coords
                }],
                coords: coords // Keep original coords for first instance
              });
            }
          } else {
            console.log(`Invalid coordinates for ${row['Name']}: `, coords);
          }
        } else {
          console.log(`No valid coordinates for ${row['Name']}: `, geoData);
        }
      });
      
      // Create markers for each location group
      locationGroups.forEach((group, key) => {
        const instances = group.instances;
        const coords = [group.x, group.y];
        
        if (instances.length === 1) {
          // Single instance - create regular marker with hit area
          const row = instances[0];
          const tier = row['Tier'] || '1'; // Default to tier 1 instead of 0
          
          console.log(`Creating single marker for ${row['Name']} with tier: ${tier}`);
          
          // Create a group for the single marker to handle events properly
          const singleMarkerGroup = mapGroup.append("g")
            .attr("class", "single-marker-group")
            .style("cursor", "pointer")
            .style("pointer-events", "all");
          
          // Store the fixed coordinates as data to prevent any movement
          singleMarkerGroup.datum({ fixedX: coords[0], fixedY: coords[1], row: row });
          
          // Add an invisible larger hit area to prevent edge cases with mouse events
          singleMarkerGroup.append("circle")
            .attr("class", "single-marker-hit-area")
            .attr("cx", coords[0])
            .attr("cy", coords[1])
            .attr("r", 8) // Larger hit area for single markers
            .attr("fill", "transparent")
            .attr("stroke", "none")
            .style("pointer-events", "all");
          
          // Create the visual marker (non-interactive)
          const tierColor = getMarkerColorByTier(tier);
          console.log(`Creating single marker for ${row['Name']}: tier=${tier}, color=${tierColor}`);
          
          const singleMarker = singleMarkerGroup.append("circle")
            .attr("class", `map-marker tier-${tier}`)
            .attr("cx", coords[0])
            .attr("cy", coords[1])
            .attr("r", 4)
            .attr("fill", tierColor)
            .attr("stroke", "white")
            .attr("stroke-width", 1) // Further reduced stroke width 
            .style("pointer-events", "none"); // Make visual marker non-interactive
          
          // Store timeout references for debouncing and tooltip state
          let singleEnterTimeout = null;
          let singleLeaveTimeout = null;
          let singleTooltipShown = false;
          
          singleMarkerGroup
            .on("mouseenter", function(event, d) {
              const timestamp = Date.now();
              console.log(`[${timestamp}] === SINGLE MARKER MOUSEENTER START ===`);
              console.log('Server Name:', d.row.Name || 'Unknown');
              console.log('Fixed coordinates stored in data:', { fixedX: d.fixedX, fixedY: d.fixedY });
              console.log('Mouse coordinates:', { mouseX: event.clientX, mouseY: event.clientY });
              console.log('Current tooltip state:', { singleTooltipShown, singleEnterTimeout: !!singleEnterTimeout, singleLeaveTimeout: !!singleLeaveTimeout });
              console.log('Event target:', event.target.tagName, event.target.classList.toString());
              console.log('Hit area working:', event.target.classList.contains('single-marker-hit-area'));
              
              // If tooltip is already shown, don't process more enter events
              if (singleTooltipShown) {
                console.log('EARLY EXIT: Tooltip already shown');
                return;
              }
              
              // Clear any pending leave timeout
              if (singleLeaveTimeout) {
                console.log('Clearing existing leave timeout');
                clearTimeout(singleLeaveTimeout);
                singleLeaveTimeout = null;
              }
              
              // Clear any pending enter timeout
              if (singleEnterTimeout) {
                console.log('Clearing existing enter timeout');
                clearTimeout(singleEnterTimeout);
              }
              
              // Use the stored fixed coordinates
              const fixedX = d.fixedX;
              const fixedY = d.fixedY;
              
              console.log('Setting new enter timeout with 150ms delay');
              
              // Set new enter timeout with increased debouncing
              singleEnterTimeout = setTimeout(() => {
                console.log(`[${Date.now()}] SINGLE ENTER TIMEOUT EXECUTED - Starting tooltip display`);
                
                // Double-check that we should still show tooltip (no recent leave events)
                if (!singleTooltipShown) {
                  const markerElement = d3.select(this).select(".map-marker");
                  
                  console.log('Starting D3 transition...');
                  
                  // Get current zoom scale for proper hover sizing
                  const currentTransform = d3.zoomTransform(this);
                  const zoomScale = currentTransform.k;
                  const markerScale = Math.max(0.3, 1 / (zoomScale * 0.8));
                  
                  markerElement
                    .transition().duration(100)
                    .attr("r", 6 * markerScale) // Scale hover size with zoom
                    .attr("stroke-width", Math.max(0.3, 3 * markerScale)) // Scale stroke with zoom
                    .attr("cx", fixedX)  // Force to exact fixed position
                    .attr("cy", fixedY); // Force to exact fixed position
                  
                  console.log('After transition - DOM coordinates:', {
                    cx: markerElement.attr('cx'),
                    cy: markerElement.attr('cy')
                  });
                  console.log('Calling showTooltip with fixed coordinates:', { fixedX, fixedY });
                  
                  // Mark tooltip as shown to prevent repeated events
                  console.log('Setting singleTooltipShown = true');
                  singleTooltipShown = true;
                  
                  showTooltip(event, d.row, fixedX, fixedY);
                } else {
                  console.log('SKIPPING tooltip display - singleTooltipShown is already true');
                }
                
                singleEnterTimeout = null;
                console.log(`[${Date.now()}] SINGLE ENTER TIMEOUT COMPLETED`);
              }, 150);
              
              console.log(`[${timestamp}] === SINGLE MARKER MOUSEENTER END ===`);
            })
            .on("mouseleave", function(event, d) {
              const timestamp = Date.now();
              console.log(`[${timestamp}] === SINGLE MARKER MOUSELEAVE START ===`);
              console.log('Current tooltip state:', { singleTooltipShown, singleEnterTimeout: !!singleEnterTimeout, singleLeaveTimeout: !!singleLeaveTimeout });
              console.log('Event target:', event.target.tagName, event.target.classList.toString());
              console.log('Hit area working:', event.target.classList.contains('single-marker-hit-area'));
              
              // Clear any pending enter timeout
              if (singleEnterTimeout) {
                console.log('CANCELLING enter timeout - tooltip will not be shown');
                clearTimeout(singleEnterTimeout);
                singleEnterTimeout = null;
              }
              
              // Clear any existing leave timeout
              if (singleLeaveTimeout) {
                console.log('Clearing existing leave timeout');
                clearTimeout(singleLeaveTimeout);
              }
              
              // Use the stored fixed coordinates
              const fixedX = d.fixedX;
              const fixedY = d.fixedY;
              
              console.log('Setting new leave timeout with 200ms delay');
              
              // Set new leave timeout with increased debouncing
              singleLeaveTimeout = setTimeout(() => {
                console.log(`[${Date.now()}] SINGLE LEAVE TIMEOUT EXECUTED - Hiding tooltip`);
                
                // Only hide if tooltip is actually shown
                if (singleTooltipShown) {
                  const markerElement = d3.select(this).select(".map-marker");
                  
                  console.log('Starting D3 transition to restore original size...');
                  
                  // Get current zoom scale for proper restoration
                  const currentTransform = d3.zoomTransform(this);
                  const zoomScale = currentTransform.k;
                  const markerScale = Math.max(0.3, 1 / (zoomScale * 0.8));
                  
                  markerElement
                    .transition().duration(100)
                    .attr("r", 4 * markerScale) // Restore zoom-scaled size
                    .attr("stroke-width", Math.max(0.3, 1 * markerScale)) // Restore zoom-scaled stroke
                    .attr("cx", fixedX)  // Force to exact fixed position
                    .attr("cy", fixedY); // Force to exact fixed position
                  
                  // Reset tooltip state
                  console.log('Setting singleTooltipShown = false');
                  singleTooltipShown = false;
                  
                  console.log('Calling hideTooltip()');
                  hideTooltip();
                } else {
                  console.log('SKIPPING tooltip hide - singleTooltipShown is already false');
                }
                
                singleLeaveTimeout = null;
                console.log(`[${Date.now()}] SINGLE LEAVE TIMEOUT COMPLETED`);
              }, 200);
              
              console.log(`[${timestamp}] === SINGLE MARKER MOUSELEAVE END ===`);
            })
            .on("click", function(event, d) {
              console.log('Single marker clicked - showing cluster details');
              // Show cluster details on click
              showClusterDetails([d.row], { fixedX: d.fixedX, fixedY: d.fixedY });
            });
            
          markersAdded++;
        } else {
          // Multiple instances - create clustered marker
          const dominantTier = getMostCommonTier(instances);
          const clusterSize = Math.min(instances.length, 10); // Cap visual size
          const radius = Math.max(6, Math.min(12, 4 + clusterSize));
          
          // Create a group for the cluster to handle events properly
          const clusterGroup = mapGroup.append("g")
            .attr("class", "cluster-group")
            .style("cursor", "pointer")
            .style("pointer-events", "all");
          
          // Store the fixed coordinates as data to prevent any movement
          clusterGroup.datum({ fixedX: coords[0], fixedY: coords[1], instances: instances, radius: radius });
          
          // Add an invisible larger hit area to prevent edge cases with mouse events
          clusterGroup.append("circle")
            .attr("class", "cluster-hit-area")
            .attr("cx", coords[0])
            .attr("cy", coords[1])
            .attr("r", radius + 5) // 5px larger than visual cluster
            .attr("fill", "transparent")
            .attr("stroke", "none")
            .style("pointer-events", "all");
          
          // Store a reference for debouncing and tooltip state
          let enterTimeout = null;
          let leaveTimeout = null;
          let tooltipShown = false;
          
          clusterGroup
            .on("mouseenter", function(event, d) {
              const timestamp = Date.now();
              console.log(`[${timestamp}] === CLUSTER MOUSEENTER START ===`);
              console.log('Cluster instances count:', d.instances.length);
              console.log('Fixed coordinates stored in data:', { fixedX: d.fixedX, fixedY: d.fixedY });
              console.log('Mouse coordinates:', { mouseX: event.clientX, mouseY: event.clientY });
              console.log('Current tooltip state:', { tooltipShown, enterTimeout: !!enterTimeout, leaveTimeout: !!leaveTimeout });
              console.log('Event target:', event.target.tagName, event.target.classList.toString());
              console.log('Event currentTarget:', event.currentTarget.tagName, event.currentTarget.classList.toString());
              console.log('Hit area working:', event.target.classList.contains('cluster-hit-area'));
              
              // If tooltip is already shown, don't process more enter events
              if (tooltipShown) {
                console.log('EARLY EXIT: Tooltip already shown');
                return;
              }
              
              // Clear any pending leave timeout
              if (leaveTimeout) {
                console.log('Clearing existing leave timeout');
                clearTimeout(leaveTimeout);
                leaveTimeout = null;
              }
              
              // Clear any pending enter timeout
              if (enterTimeout) {
                console.log('Clearing existing enter timeout');
                clearTimeout(enterTimeout);
              }
              
              // Use the stored fixed coordinates - never use mouse position
              const fixedX = d.fixedX;
              const fixedY = d.fixedY;
              
              console.log('Setting new enter timeout with 150ms delay');
              
              // Set new enter timeout with increased debouncing to reduce sensitivity
              enterTimeout = setTimeout(() => {
                console.log(`[${Date.now()}] ENTER TIMEOUT EXECUTED - Starting tooltip display`);
                
                // Double-check that we should still show tooltip (no recent leave events)
                if (!tooltipShown) {
                  const clusterElement = d3.select(this).select(".marker-cluster");
                  
                  console.log('Cluster element found:', !clusterElement.empty());
                  console.log('Current cluster DOM coordinates:', {
                    cx: clusterElement.attr('cx'),
                    cy: clusterElement.attr('cy'),
                    r: clusterElement.attr('r')
                  });
                  
                  console.log('Starting D3 transition...');
                  
                  // Get current zoom scale for proper hover sizing
                  const currentTransform = d3.zoomTransform(this);
                  const zoomScale = currentTransform.k;
                  const markerScale = Math.max(0.3, 1 / (zoomScale * 0.8));
                  
                  clusterElement
                    .transition().duration(100)
                    .attr("r", (d.radius + 2) * markerScale) // Scale hover size with zoom
                    .attr("stroke-width", Math.max(0.3, 4 * markerScale)) // Scale stroke with zoom
                    .attr("cx", fixedX)  // Force to exact fixed position
                    .attr("cy", fixedY); // Force to exact fixed position
                  
                  console.log('After transition - cluster DOM coordinates:', {
                    cx: clusterElement.attr('cx'),
                    cy: clusterElement.attr('cy'),
                    r: clusterElement.attr('r')
                  });
                  
                  // Mark tooltip as shown to prevent repeated events
                  console.log('Setting tooltipShown = true');
                  tooltipShown = true;
                  
                  console.log('Calling showClusterTooltip with fixed coordinates:', { fixedX, fixedY });
                  
                  if (d.instances.length === 1) {
                    showTooltip(event, d.instances[0], fixedX, fixedY);
                  } else {
                    showClusterTooltip(event, d.instances, fixedX, fixedY);
                  }
                } else {
                  console.log('SKIPPING tooltip display - tooltipShown is already true');
                }
                
                enterTimeout = null;
                console.log(`[${Date.now()}] ENTER TIMEOUT COMPLETED`);
              }, 150);
              
              console.log(`[${timestamp}] === CLUSTER MOUSEENTER END ===`);
            })
            .on("mouseleave", function(event, d) {
              const timestamp = Date.now();
              console.log(`[${timestamp}] === CLUSTER MOUSELEAVE START ===`);
              console.log('Current tooltip state:', { tooltipShown, enterTimeout: !!enterTimeout, leaveTimeout: !!leaveTimeout });
              console.log('Event target:', event.target.tagName, event.target.classList.toString());
              console.log('Event currentTarget:', event.currentTarget.tagName, event.currentTarget.classList.toString());
              console.log('Hit area working:', event.target.classList.contains('cluster-hit-area'));
              console.log('Mouse coordinates:', { mouseX: event.clientX, mouseY: event.clientY });
              
              // Clear any pending enter timeout
              if (enterTimeout) {
                console.log('CANCELLING enter timeout - tooltip will not be shown');
                clearTimeout(enterTimeout);
                enterTimeout = null;
              }
              
              // Clear any existing leave timeout
              if (leaveTimeout) {
                console.log('Clearing existing leave timeout');
                clearTimeout(leaveTimeout);
              }
              
              // Use the stored fixed coordinates - never use mouse position
              const fixedX = d.fixedX;
              const fixedY = d.fixedY;
              
              console.log('Setting new leave timeout with 200ms delay');
              
              // Set new leave timeout with increased debouncing to reduce sensitivity
              leaveTimeout = setTimeout(() => {
                console.log(`[${Date.now()}] LEAVE TIMEOUT EXECUTED - Hiding tooltip`);
                
                // Only hide if tooltip is actually shown
                if (tooltipShown) {
                  const clusterElement = d3.select(this).select(".marker-cluster");
                  
                  console.log('Starting D3 transition to restore original size...');
                  
                  // Get current zoom scale for proper restoration  
                  const currentTransform = d3.zoomTransform(this);
                  const zoomScale = currentTransform.k;
                  const markerScale = Math.max(0.3, 1 / (zoomScale * 0.8));
                  
                  clusterElement
                    .transition().duration(100)
                    .attr("r", d.radius * markerScale) // Restore zoom-scaled size
                    .attr("stroke-width", Math.max(0.3, 2 * markerScale)) // Restore zoom-scaled stroke
                    .attr("cx", fixedX)  // Force to exact fixed position
                    .attr("cy", fixedY); // Force to exact fixed position
                  
                  // Reset tooltip state
                  console.log('Setting tooltipShown = false');
                  tooltipShown = false;
                  
                  console.log('Calling hideTooltip()');
                  hideTooltip();
                } else {
                  console.log('SKIPPING tooltip hide - tooltipShown is already false');
                }
                
                leaveTimeout = null;
                console.log(`[${Date.now()}] LEAVE TIMEOUT COMPLETED`);
              }, 200);
              
              console.log(`[${timestamp}] === CLUSTER MOUSELEAVE END ===`);
            })
            .on("click", function(event, d) {
              console.log('Cluster marker clicked - showing cluster details');
              // Show cluster details on click
              showClusterDetails(d.instances, { fixedX: d.fixedX, fixedY: d.fixedY });
            });
          
          // Create cluster background circle (visual only, no mouse events)
          clusterGroup.append("circle")
            .attr("class", `marker-cluster cluster-tier-${dominantTier}`)
            .attr("cx", coords[0])
            .attr("cy", coords[1])
            .attr("r", radius)
            .attr("fill", getMarkerColorByTier(dominantTier))
            .attr("stroke", "white")
            .attr("stroke-width", 2) // Reduced stroke width
            .attr("opacity", 0.8)
            .style("pointer-events", "none"); // Make visual circle non-interactive
          
          // Add count text on cluster - make it completely non-interactive
          clusterGroup.append("text")
            .attr("class", "cluster-text")
            .attr("x", coords[0])
            .attr("y", coords[1])
            .attr("dy", "0.35em")
            .attr("text-anchor", "middle")
            .attr("fill", "white")
            .attr("font-size", "10px")
            .attr("font-weight", "bold")
            .attr("pointer-events", "none")
            .style("user-select", "none")
            .style("pointer-events", "none") // Ensure text never captures mouse events
            .text(instances.length);
            
          markersAdded += instances.length;
        }
      });
      
      console.log(`Total markers added to map: ${markersAdded} out of ${dataToRender.length} servers in ${locationGroups.size} location groups`);
      
      // Add a legend
      addMapLegend();
    }
    
    // Helper function to find the most common tier in a group
    function getMostCommonTier(instances) {
      const tierCounts = {};
      instances.forEach(instance => {
        const tier = instance['Tier'] || '0';
        tierCounts[tier] = (tierCounts[tier] || 0) + 1;
      });
      
      return Object.keys(tierCounts).reduce((a, b) => 
        tierCounts[a] > tierCounts[b] ? a : b
      );
    }
    
    // Helper function to get marker color by tier
    function getMarkerColorByTier(tier) {
      const tierColors = {
        '1': '#4caf50',    // Global Instance - Green
        '2': '#ff9800',    // National Instance - Orange  
        '3': '#2196f3',    // Subdomain - Blue
        '4': '#9c27b0',    // Institutional - Purple
        '5': '#607d8b',    // Integrated Platform - Blue Grey
        '6': '#795548'     // Development Instance - Brown
      };
      
      // Ensure we have a valid tier string
      const tierStr = String(tier || '1').trim();
      // console.log(`Getting color for tier: "${tierStr}"`);
      
      return tierColors[tierStr] || '#4caf50'; // Default to green (tier 1) for unknown tiers
    }

    // Helper function to get marker color by status (keeping for reference)
    function getMarkerColorByStatus(statusClass) {
      const colors = {
        'online': '#4caf50',
        'issues': '#ff9800', 
        'offline': '#f44336',
        'unknown': '#999'
      };
      return colors[statusClass] || '#999';
    }
    
    // Add legend to the map
    function addMapLegend() {
      const mapContainer = document.getElementById('map-container');
      
      // Remove existing legend
      const existingLegend = mapContainer.querySelector('.map-legend');
      if (existingLegend) {
        existingLegend.remove();
      }
      
      // Count servers by tier from the current filtered data
      const tierCounts = {
        '1': 0, // Global Instance
        '2': 0, // National Instance
        '3': 0, // Subdomain
        '4': 0, // Institutional
        '5': 0, // Integrated Platform
        '6': 0  // Development Instance
      };
      
      filteredData.forEach(row => {
        const tier = row['Tier'] || '1'; // Default to tier 1 if not specified
        if (tierCounts.hasOwnProperty(tier)) {
          tierCounts[tier]++;
        }
      });
      
      const legend = document.createElement('div');
      legend.className = 'map-legend';
      legend.style.cssText = `
        position: absolute;
        top: 10px;
        right: 10px;
        background: rgba(255, 255, 255, 0.9);
        padding: 10px;
        border-radius: 6px;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
        font-size: 12px;
        z-index: 100;
      `;
      
      legend.innerHTML = `
        <div style="font-weight: bold; margin-bottom: 5px;">Instance Tiers</div>
        <div style="margin: 3px 0;"><span style="color: #4caf50;">●</span> Global Instance (${tierCounts['1']})</div>
        <div style="margin: 3px 0;"><span style="color: #ff9800;">●</span> National Instance (${tierCounts['2']})</div>
        <div style="margin: 3px 0;"><span style="color: #2196f3;">●</span> Subdomain (${tierCounts['3']})</div>
        <div style="margin: 3px 0;"><span style="color: #9c27b0;">●</span> Institutional (${tierCounts['4']})</div>
        <div style="margin: 3px 0;"><span style="color: #607d8b;">●</span> Integrated Platform (${tierCounts['5']})</div>
        <div style="margin: 3px 0;"><span style="color: #795548;">●</span> Development Instance (${tierCounts['6']})</div>
        <div style="margin-top: 8px; font-size: 11px; color: #666; font-style: italic;">
          Numbers show multiple instances<br>at the same location
        </div>
      `;
      
      mapContainer.appendChild(legend);
    }

    // Show cluster details in the container beneath the map
    function showClusterDetails(instances, location) {
      const container = document.getElementById('cluster-details-container');
      const title = document.getElementById('cluster-title');
      const content = document.getElementById('cluster-details-content');
      
      // Get location info from first instance
      const geoData = instances[0]['GeoLocation'] || {};
      const city = geoData.city || 'Unknown City';
      const country = geoData.country || 'Unknown Country';
      const flag = geoData.flag || '🏳️';
      
      const locationDisplay = city && city !== 'Unknown' && city !== 'Unknown City' ? 
        `${city}, ${country}` : 
        country;
      
      title.textContent = `${flag} ${locationDisplay} (${instances.length} instance${instances.length > 1 ? 's' : ''})`;
      
      // Clear existing content
      content.innerHTML = '';
      
      // Sort instances by tier and name
      const sortedInstances = instances.sort((a, b) => {
        const tierA = parseInt(a['Tier'] || '99');
        const tierB = parseInt(b['Tier'] || '99');
        if (tierA !== tierB) return tierA - tierB;
        return (a['Name'] || '').localeCompare(b['Name'] || '');
      });
      
      // Create table container
      const tableContainer = document.createElement('div');
      tableContainer.className = 'cluster-details-table-container';
      
      // Create table
      const table = document.createElement('table');
      table.className = 'cluster-details-table';
      
      // Create table header
      const thead = document.createElement('thead');
      thead.innerHTML = `
        <tr>
          <th>Instance</th>
          <th>Tier</th>
          <th>Region</th>
          <th>Description</th>
          <th>Location</th>
          <th>Coordinates</th>
        </tr>
      `;
      table.appendChild(thead);
      
      // Create table body
      const tbody = document.createElement('tbody');
      
      sortedInstances.forEach(instance => {
        const tier = instance['Tier'] || '0';
        const tierInfo = getTierInfo(tier);
        const geoData = instance['GeoLocation'] || {};
        
        const row = document.createElement('tr');
        
        // Get URL for linking
        const url = instance['URL'] || 'No URL';
        
        // Strip protocol for display
        const displayUrl = url !== 'No URL' ? url.replace(/^https?:\/\//, '') : 'No URL';
        
        // Parse description and notes
        const descriptionText = instance['Description'] || '';
        const notesText = instance['Notes'] || '';
        
        let descriptionContent = parseMarkdownLinks(descriptionText);
        let descriptionHtml = '';
        
        if (descriptionContent) {
          descriptionHtml += `<div>${descriptionContent}</div>`;
        }
        
        if (notesText) {
          descriptionHtml += `<div class="description-notes" style="font-size: 0.9em; color: #666; margin-top: 4px;">${notesText}</div>`;
        }
        
        row.innerHTML = `
          <td style="font-weight: 600;">
            ${url !== 'No URL' ? 
              `<a href="${url}" target="_blank" class="server-url" style="font-weight: 600; color: #007bff; text-decoration: none;">${instance['Name'] || 'Unknown Instance'}</a>
               <div style="font-size: 0.85em; color: #6c757d; margin-top: 2px;">${displayUrl}</div>` :
              `<div style="font-weight: 600;">${instance['Name'] || 'Unknown Instance'}</div>
               <div style="font-size: 0.85em; color: #6c757d; margin-top: 2px; font-style: italic;">No URL</div>`
            }
          </td>
          <td>
            <span class="tier-badge tier-${tier}" title="${tierInfo.name}">
              ${tierInfo.icon} ${tierInfo.name}
            </span>
          </td>
          <td>${instance['Region'] || 'Unknown'}</td>
          <td>
            <div class="description-info">
              ${descriptionHtml || '<span style="color: #999; font-style: italic;">No description</span>'}
            </div>
          </td>
          <td>
            <div class="location-info">
              <span class="country-flag">${geoData.flag || '🏳️'}</span>
              ${geoData.city && geoData.city !== 'Unknown' && geoData.city !== 'Unknown City' ? 
                `${geoData.city}, ${geoData.country || 'Unknown'}` : 
                `${geoData.country || 'Unknown'}`
              }
            </div>
          </td>
          <td>
            ${geoData.latitude && geoData.longitude ? 
              `<div class="coordinates">${geoData.latitude.toFixed(4)}, ${geoData.longitude.toFixed(4)}</div>` : 
              '<span style="color: #999;">Unknown</span>'
            }
          </td>
        `;
        
        tbody.appendChild(row);
      });
      
      table.appendChild(tbody);
      tableContainer.appendChild(table);
      content.appendChild(tableContainer);
      
      // Show the container
      container.style.display = 'block';
      
      // Scroll to the cluster details
      container.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
    }

    // Hide cluster details
    function hideClusterDetails() {
      const container = document.getElementById('cluster-details-container');
      container.style.display = 'none';
    }

    // Show tooltip for clustered markers
    function showClusterTooltip(event, instances, markerX = null, markerY = null) {
      // Remove any existing tooltips first
      hideTooltip();
      
      console.log('=== SHOW CLUSTER TOOLTIP START ===');
      console.log('Timestamp:', Date.now());
      console.log('Cluster instances count:', instances.length);
      console.log('Provided marker coordinates:', { markerX, markerY });
      console.log('Event client coordinates:', { clientX: event.clientX, clientY: event.clientY });
      console.log('Existing tooltips in DOM:', document.querySelectorAll('.marker-tooltip').length);
      
      const tooltip = document.createElement('div');
      tooltip.className = 'marker-tooltip cluster-tooltip';
      
      let tooltipX, tooltipY;
      
      if (markerX !== null && markerY !== null) {
        // Use fixed marker coordinates if provided - calculate absolute position correctly
        const svgElement = document.getElementById('world-map');
        const svgRect = svgElement.getBoundingClientRect();
        const scrollX = window.pageXOffset || document.documentElement.scrollLeft;
        const scrollY = window.pageYOffset || document.documentElement.scrollTop;
        
        // Get current zoom transform to account for scaling/translation
        const mapGroup = d3.select(svgElement).select('.map-group');
        const transform = d3.zoomTransform(mapGroup.node() || svgElement);
        
        // Apply transform to marker coordinates
        const transformedX = transform.applyX(markerX);
        const transformedY = transform.applyY(markerY);
        
        tooltipX = svgRect.left + scrollX + transformedX;
        tooltipY = svgRect.top + scrollY + transformedY;
        
        console.log('Using FIXED coordinates for cluster tooltip positioning:');
        console.log('SVG element rect:', { left: svgRect.left, top: svgRect.top, width: svgRect.width, height: svgRect.height });
        console.log('Zoom transform:', { k: transform.k, x: transform.x, y: transform.y });
        console.log('Original marker coords:', { markerX, markerY });
        console.log('Transformed marker coords:', { transformedX, transformedY });
        console.log('Scroll offsets:', { scrollX, scrollY });
        console.log('Final calculated tooltip position:', { tooltipX, tooltipY });
      } else {
        // Fallback to event coordinates
        const rect = event.target.getBoundingClientRect();
        const scrollX = window.pageXOffset || document.documentElement.scrollLeft;
        const scrollY = window.pageYOffset || document.documentElement.scrollTop;
        
        tooltipX = rect.left + scrollX + rect.width / 2;
        tooltipY = rect.top + scrollY;
        
        console.log('Using EVENT coordinates for cluster tooltip positioning:');
        console.log('Event target rect:', { left: rect.left, top: rect.top, width: rect.width, height: rect.height });
        console.log('Scroll offsets:', { scrollX, scrollY });
        console.log('Calculated tooltip position:', { tooltipX, tooltipY });
      }
      
      tooltip.style.cssText = `
        position: absolute;
        left: ${tooltipX + 15}px;
        top: ${tooltipY - 10}px;
        background: rgba(0, 0, 0, 0.9);
        color: white;
        padding: 12px;
        border-radius: 6px;
        font-size: 12px;
        font-family: Arial, sans-serif;
        pointer-events: none;
        z-index: 10000;
        max-width: 300px;
        max-height: 400px;
        overflow-y: auto;
        border: 1px solid rgba(255,255,255,0.1);
        box-shadow: 0 2px 8px rgba(0,0,0,0.3);
      `;
      
      console.log('Final cluster tooltip CSS position:', { left: tooltipX + 15, top: tooltipY - 10 });
      
      // Get location info from first instance
      const geoData = instances[0]['GeoLocation'] || {};
      
      // Group instances by tier for summary
      const tierGroups = {};
      const statusGroups = { online: 0, issues: 0, offline: 0, unknown: 0 };
      
      instances.forEach(instance => {
        const tier = instance['Tier'] || '0';
        const tierInfo = getTierInfo(tier);
        if (!tierGroups[tier]) {
          tierGroups[tier] = { name: tierInfo.name, icon: tierInfo.icon, instances: [] };
        }
        tierGroups[tier].instances.push(instance);
        
        // Count status
        const status = getStatusIcon(instance['Version'] || '', instance['Tool Count'] || '', instance['Tier'] || '');
        statusGroups[status.class] = (statusGroups[status.class] || 0) + 1;
      });
      
      const city = geoData.city || 'Unknown City';
      const country = geoData.country || 'Unknown Country';
      const flag = geoData.flag || '🏳️';
      
      const locationDisplay = city && city !== 'Unknown' && city !== 'Unknown City' ? 
        `${city}, ${country}` : 
        country;
      
      let content = `
        <div style="font-weight: bold; margin-bottom: 8px;">
          ${flag} ${locationDisplay}
        </div>
        <div style="margin-bottom: 8px; color: #ccc;">
          ${instances.length} Galaxy Instance${instances.length > 1 ? 's' : ''}
        </div>
      `;
      
      // Add tier breakdown
      Object.keys(tierGroups).forEach(tier => {
        const group = tierGroups[tier];
        content += `
          <div style="margin: 4px 0; font-size: 11px;">
            ${group.icon} ${group.name}: ${group.instances.length}
          </div>
        `;
      });
      
      // Add status summary
      const statusIcons = { online: '🟢', issues: '🟡', offline: '🔴', unknown: '⏳' };
      content += '<div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid #666; font-size: 11px;">';
      Object.keys(statusGroups).forEach(status => {
        if (statusGroups[status] > 0) {
          content += `<span style="margin-right: 8px;">${statusIcons[status]} ${statusGroups[status]}</span>`;
        }
      });
      content += '</div>';
      
      // Add individual instances (limit to first 10 to avoid overwhelming)
      if (instances.length <= 10) {
        content += '<div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid #666;">';
        instances.forEach(instance => {
          const status = getStatusIcon(instance['Version'] || '', instance['Tool Count'] || '', instance['Tier'] || '');
          const tierInfo = getTierInfo(instance['Tier'] || '');
          const instanceName = instance['Name'] || instance['Server Name'] || 'Unknown';
          content += `
            <div style="margin: 2px 0; font-size: 10px; color: #ddd;">
              ${status.icon} ${tierInfo.icon} ${instanceName}
            </div>
          `;
        });
        content += '</div>';
      } else {
        content += `<div style="margin-top: 8px; font-size: 10px; color: #aaa; font-style: italic;">
          Click to view all ${instances.length} instances in table
        </div>`;
      }
      
      tooltip.innerHTML = content;
      
      console.log('Appending tooltip to document.body...');
      console.log('Tooltip element created:', tooltip);
      console.log('Tooltip innerHTML length:', tooltip.innerHTML.length);
      
      document.body.appendChild(tooltip);
      
      // Store reference for cleanup
      tooltip.setAttribute('data-tooltip-id', 'cluster-tooltip');
      
      console.log('Cluster tooltip successfully appended to DOM');
      console.log('DOM now contains tooltips:', document.querySelectorAll('.marker-tooltip').length);
      console.log('=== SHOW CLUSTER TOOLTIP END ===');
    }

    // Show tooltip for map markers
    function showTooltip(event, row, markerX = null, markerY = null) {
      // Remove any existing tooltips first
      hideTooltip();
      
      // Validate input data
      if (!row || !event) {
        console.log('showTooltip: Missing row or event data');
        return;
      }
      
      console.log('=== SHOW TOOLTIP DEBUG ===');
      console.log('Server Name:', row.Name || 'Unknown');
      console.log('Provided marker coordinates:', { markerX, markerY });
      console.log('Event client coordinates:', { clientX: event.clientX, clientY: event.clientY });
      
      const tooltip = document.createElement('div');
      tooltip.className = 'marker-tooltip';
      
      let tooltipX, tooltipY;
      
      if (markerX !== null && markerY !== null) {
        // Use fixed marker coordinates if provided - calculate absolute position correctly
        const svgElement = document.getElementById('world-map');
        const svgRect = svgElement.getBoundingClientRect();
        const scrollX = window.pageXOffset || document.documentElement.scrollLeft;
        const scrollY = window.pageYOffset || document.documentElement.scrollTop;
        
        // Get current zoom transform to account for scaling/translation
        const mapGroup = d3.select(svgElement).select('.map-group');
        const transform = d3.zoomTransform(mapGroup.node() || svgElement);
        
        // Apply transform to marker coordinates
        const transformedX = transform.applyX(markerX);
        const transformedY = transform.applyY(markerY);
        
        tooltipX = svgRect.left + scrollX + transformedX;
        tooltipY = svgRect.top + scrollY + transformedY;
        
        console.log('Using FIXED coordinates for tooltip positioning:');
        console.log('SVG element rect:', { left: svgRect.left, top: svgRect.top, width: svgRect.width, height: svgRect.height });
        console.log('Zoom transform:', { k: transform.k, x: transform.x, y: transform.y });
        console.log('Original marker coords:', { markerX, markerY });
        console.log('Transformed marker coords:', { transformedX, transformedY });
        console.log('Scroll offsets:', { scrollX, scrollY });
        console.log('Final calculated tooltip position:', { tooltipX, tooltipY });
      } else {
        // Fallback to event coordinates
        const rect = event.target.getBoundingClientRect();
        const scrollX = window.pageXOffset || document.documentElement.scrollLeft;
        const scrollY = window.pageYOffset || document.documentElement.scrollTop;
        
        tooltipX = rect.left + scrollX + rect.width / 2;
        tooltipY = rect.top + scrollY;
        
        console.log('Using EVENT coordinates for tooltip positioning:');
        console.log('Event target rect:', { left: rect.left, top: rect.top, width: rect.width, height: rect.height });
        console.log('Scroll offsets:', { scrollX, scrollY });
        console.log('Calculated tooltip position:', { tooltipX, tooltipY });
      }
      
      tooltip.style.cssText = `
        position: absolute;
        left: ${tooltipX + 15}px;
        top: ${tooltipY - 10}px;
        background: rgba(0, 0, 0, 0.9);
        color: white;
        padding: 10px 14px;
        border-radius: 6px;
        font-size: 12px;
        font-family: Arial, sans-serif;
        pointer-events: auto;
        z-index: 10000;
        max-width: 300px;
        white-space: normal;
        box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        border: 1px solid rgba(255,255,255,0.1);
        line-height: 1.4;
      `;
      
      console.log('Final tooltip CSS position:', { left: tooltipX + 15, top: tooltipY - 10 });
      
      const geoData = row['GeoLocation'] || {};
      const tierInfo = getTierInfo(row['Tier'] || '');
      
      const serverName = row['Name'] || row['Server Name'] || 'Unknown Instance';
      const city = geoData.city || 'Unknown City';
      const country = geoData.country || 'Unknown Country';
      const flag = geoData.flag || '🏳️';
      
      const locationDisplay = city && city !== 'Unknown' && city !== 'Unknown City' ? 
        `${city}, ${country}` : 
        country;
      
      // Get URL, description, and notes
      const url = row['URL'] || 'No URL';
      const description = row['Description'] || '';
      const notes = row['Notes'] || '';
      
      // Parse markdown links in description
      const parsedDescription = parseMarkdownLinks(description);
      
      // Format URL for display (truncate if too long)
      const urlDisplay = url.length > 50 ? url.substring(0, 47) + '...' : url;
      
      tooltip.innerHTML = `
        <div style="font-weight: bold; margin-bottom: 4px;">${serverName}</div>
        <div style="margin-bottom: 4px;">${flag} ${locationDisplay}</div>
        <div style="margin-bottom: 4px;">${tierInfo.icon} ${tierInfo.name}</div>
        ${url !== 'No URL' ? `<div style="margin-bottom: 4px;">
          <a href="${url}" target="_blank" rel="noopener noreferrer" 
             style="color: #4da6ff; text-decoration: underline; pointer-events: auto;">
            ${urlDisplay}
          </a>
        </div>` : ''}
        ${parsedDescription ? `<div style="margin-bottom: 4px; font-style: italic; color: #cccccc;">
          ${parsedDescription}
        </div>` : ''}
        ${notes ? `<div style="color: #ffcc99; font-size: 11px;">
          ${notes.length > 80 ? notes.substring(0, 77) + '...' : notes}
        </div>` : ''}
      `;
      
      document.body.appendChild(tooltip);
      
      // Store reference for cleanup
      tooltip.setAttribute('data-tooltip-id', 'single-tooltip');
      
      console.log('Tooltip created and appended to DOM');
      console.log('=== END SHOW TOOLTIP DEBUG ===');
    }

    // Hide tooltip
    function hideTooltip() {
      console.log('=== HIDE TOOLTIP START ===');
      console.log('Timestamp:', Date.now());
      const tooltips = document.querySelectorAll('.marker-tooltip');
      console.log('Found tooltips to remove:', tooltips.length);
      
      tooltips.forEach((tooltip, index) => {
        console.log(`Removing tooltip ${index + 1}:`, tooltip.getAttribute('data-tooltip-id'));
        if (tooltip.parentNode) {
          tooltip.parentNode.removeChild(tooltip);
          console.log(`Tooltip ${index + 1} removed successfully`);
        } else {
          console.log(`Tooltip ${index + 1} has no parent node`);
        }
      });
      
      console.log('Remaining tooltips after cleanup:', document.querySelectorAll('.marker-tooltip').length);
      console.log('=== HIDE TOOLTIP END ===');
    }

    // Render the location table
    function renderTable() {
      const tbody = document.querySelector('#location-table tbody');
      tbody.innerHTML = '';
      
      if (filteredData.length === 0) {
        tbody.innerHTML = '<tr><td colspan="6" class="no-results">No instances match your search criteria.</td></tr>';
        return;
      }
      
      filteredData.forEach(row => {
        const tr = document.createElement('tr');
        
        const geoData = row['GeoLocation'] || {};
        const status = getStatusIcon(row['Version'], row['Tool Count'], row['Tier']);
        const tierInfo = getTierInfo(row['Tier']);
        
        // Parse description and notes
        const descriptionText = row['Description'] || '';
        const notesText = row['Notes'] || '';
        
        // Ensure URL has protocol for linking, handle localhost proxy URLs, and strip protocol for display
        let url = row['URL'] || '';
        let displayUrl = url.replace(/^https?:\/\//, '');
        // If URL is a localhost proxy (e.g., http://localhost:8001/dintor.eurac.edu), extract the domain
        const localhostMatch = url.match(/localhost:\d+\/(\S+\.[a-z]{2,})/i);
        if (localhostMatch) {
          url = 'https://' + localhostMatch[1];
          displayUrl = localhostMatch[1];
        } else if (url && !/^https?:\/\//i.test(url)) {
          url = 'https://' + url;
        }
        
        let descriptionContent = parseMarkdownLinks(descriptionText);
        let descriptionHtml = '';
        
        if (descriptionContent) {
          descriptionHtml += `<div>${descriptionContent}</div>`;
        }
        
        if (notesText) {
          descriptionHtml += `<div class="description-notes" style="font-size: 0.9em; color: #666; margin-top: 4px;">${notesText}</div>`;
        }
        
        tr.innerHTML = `
          <td>
            ${row['URL'] ? 
              `<a href="${url}" target="_blank" class="server-url" style="font-weight: 600; color: #007bff; text-decoration: none;">${row['Name'] || 'Unknown'}</a>
               <div style="font-size: 0.85em; color: #6c757d; margin-top: 2px;">${displayUrl}</div>` :
              `<div style="font-weight: 600;">${row['Name'] || 'Unknown'}</div>
               <div style="font-size: 0.85em; color: #6c757d; margin-top: 2px; font-style: italic;">No URL</div>`
            }
          </td>
          <td>
            <span class="tier-icon" style="color: ${tierInfo.color}">${tierInfo.icon}</span>
            ${tierInfo.name}
          </td>
          <td>${row['Region'] || 'Unknown'}</td>
          <td>
            <div class="description-info">
              ${descriptionHtml || '<span style="color: #999; font-style: italic;">No description</span>'}
            </div>
          </td>
          <td>
            <div class="location-info">
              <div>
                <span class="country-flag">${geoData.flag || '🏳️'}</span>
                ${geoData.city && geoData.city !== 'Unknown' && geoData.city !== 'Unknown City' ? 
                  `${geoData.city}, ${geoData.country || 'Unknown'}` : 
                  `${geoData.country || 'Unknown'}`
                }
              </div>
            </div>
          </td>
          <td>
            ${geoData.latitude && geoData.longitude ? 
              `<div class="coordinates">${geoData.latitude.toFixed(4)}, ${geoData.longitude.toFixed(4)}</div>` : 
              '<span style="color: #999;">Unknown</span>'
            }
          </td>
        `;
        
        tbody.appendChild(tr);
      });
    }

    // Search and filter functionality
    function performFilter() {
      const searchTerm = document.getElementById('search-input').value.toLowerCase().trim();
      
      if (searchTerm === '') {
        filteredData = [...currentData];
      } else {
        filteredData = currentData.filter(row => {
          const geoData = row['GeoLocation'] || {};
          return (
            (row['Name'] || '').toLowerCase().includes(searchTerm) ||
            (row['Region'] || '').toLowerCase().includes(searchTerm) ||
            (row['URL'] || '').toLowerCase().includes(searchTerm) ||
            (geoData.country || '').toLowerCase().includes(searchTerm) ||
            (geoData.city || '').toLowerCase().includes(searchTerm)
          );
        });
      }
      
      renderCurrentView();
      updateSummaryStats();
    }

    // Export to CSV
    function exportToCSV() {
      if (!filteredData || filteredData.length === 0) {
        alert('No data to export.');
        return;
      }
      
      const headers = ['Name', 'URL', 'Region', 'Tier', 'Country', 'City', 'Latitude', 'Longitude', 'Description', 'Notes'];
      const csvRows = [headers.join(',')];
      
      filteredData.forEach(row => {
        const geoData = row['GeoLocation'] || {};
        const csvRow = [
          `"${(row['Name'] || '').replace(/"/g, '""')}"`,
          `"${(row['URL'] || '').replace(/"/g, '""')}"`,
          `"${(row['Region'] || '').replace(/"/g, '""')}"`,
          `"${(row['Tier'] || '').replace(/"/g, '""')}"`,
          `"${(geoData.country || '').replace(/"/g, '""')}"`,
          `"${(geoData.city || '').replace(/"/g, '""')}"`,
          geoData.latitude || '',
          geoData.longitude || '',
          `"${(row['Description'] || '').replace(/"/g, '""')}"`,
          `"${(row['Notes'] || '').replace(/"/g, '""')}"`
        ];
        csvRows.push(csvRow.join(','));
      });
      
      const csvContent = csvRows.join('\n');
      const blob = new Blob([csvContent], { type: 'text/csv' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      
      const now = new Date();
      const timestamp = now.getFullYear() + 
        String(now.getMonth() + 1).padStart(2, '0') + 
        String(now.getDate()).padStart(2, '0') + '_' +
        String(now.getHours()).padStart(2, '0') + 
        String(now.getMinutes()).padStart(2, '0') + 
        String(now.getSeconds()).padStart(2, '0');
      
      a.download = `galaxy_instances_map_${timestamp}.csv`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    // Function to refresh geolocation for all servers (clears cache and re-fetches)
    async function refreshServerLocations() {
      console.log('Clearing geolocation cache and refreshing all server locations...');
      clearGeoCache();
      
      updateStatus('Refreshing server locations...', 'loading');
      await geolocateAllServers(true); // Force refresh
      
      updateSummaryStats();
      renderCurrentView();
      updateStatus(`Server locations refreshed. Updated geolocation data.`, 'success');
    }

    // Initialize the application
    function initializeApp() {
      // View toggle functionality
      document.getElementById('map-view').addEventListener('click', () => {
        currentView = 'map';
        document.getElementById('map-view').classList.add('active');
        document.getElementById('table-view').classList.remove('active');
        renderCurrentView();
      });
      
      document.getElementById('table-view').addEventListener('click', () => {
        currentView = 'table';
        document.getElementById('table-view').classList.add('active');
        document.getElementById('map-view').classList.remove('active');
        renderCurrentView();
      });
      
      // Search functionality
      document.getElementById('search-input').addEventListener('input', performFilter);
      
      // Button functionality
      document.getElementById('refresh-button').addEventListener('click', () => {
        location.reload();
      });
      
      document.getElementById('export-button').addEventListener('click', exportToCSV);
      
      document.getElementById('geolocate-button').addEventListener('click', async () => {
        const button = document.getElementById('geolocate-button');
        button.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Refreshing...';
        button.disabled = true;
        
        updateStatus('Refreshing location data...', 'loading');
        clearGeoCache();
        await geolocateAllServers(true);
        
        renderCurrentView();
        updateSummaryStats();
        updateStatus('Location data refreshed successfully.', 'success');
        
        button.innerHTML = '<i class="fas fa-map-marked-alt"></i> Refresh Locations';
        button.disabled = false;
      });
      
      // Close cluster details button
      document.getElementById('close-cluster-details').addEventListener('click', () => {
        hideClusterDetails();
      });
      
      // Load initial data
      loadSpreadsheetData();
    }

    // Start the application when DOM is loaded
    document.addEventListener('DOMContentLoaded', initializeApp);

    // Function to parse markdown links in description text
    function parseMarkdownLinks(text) {
      if (!text || typeof text !== 'string') {
        return text || '';
      }
      
      // Regular expression to match markdown links: [text](url)
      const markdownLinkRegex = /\[([^\]]+)\]\(([^)]+)\)/g;
      
      // Replace all markdown links with HTML anchor tags
      return text.replace(markdownLinkRegex, (match, linkText, url) => {
        // Only add protocol if none is present (preserve existing http:// or https://)
        let cleanUrl = url.trim();
        if (!cleanUrl.startsWith('http://') && !cleanUrl.startsWith('https://')) {
          cleanUrl = 'https://' + cleanUrl;
        }
        
        return `<a href="${cleanUrl}" target="_blank" rel="noopener noreferrer" style="color: #4da6ff; text-decoration: underline; pointer-events: auto;">${linkText.trim()}</a>`;
      });
    }
  </script>
</body>
</html>

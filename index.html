<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Galaxy Server Tracker</title>
  <style>
    body {
      font-family: sans-serif;
      padding: 2rem;
      background: #f4f4f4;
    }
    
    .header-section {
      background: #fff;
      padding: 1.5rem;
      margin-bottom: 1rem;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    
    .summary-stats {
      display: flex;
      gap: 1.5rem;
      font-size: 1rem;
    }
    
    .stat-box {
      background: #e3f2fd;
      padding: 0.75rem;
      border-radius: 6px;
      text-align: center;
      min-width: 100px;
    }
    
    .stat-number {
      font-size: 1.2rem;
      font-weight: bold;
      color: #1976d2;
    }
    
    .spreadsheet-link {
      margin: 1rem 0;
      padding: 0.75rem;
      background: #f5f5f5;
      border-radius: 4px;
      border-left: 4px solid #2196f3;
    }
    
    .search-container {
      margin: 1rem 0;
    }
    
    .search-input {
      width: 100%;
      padding: 0.75rem;
      border: 1px solid #ccc;
      border-radius: 4px;
      font-size: 1rem;
      box-sizing: border-box;
    }
    
    .search-input:focus {
      border-color: #2196f3;
      outline: none;
      box-shadow: 0 0 0 2px rgba(33, 150, 243, 0.2);
    }
    
    table {
      width: 100%;
      border-collapse: collapse;
      background: #fff;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    
    th, td {
      padding: 0.75rem;
      border: 1px solid #ccc;
      text-align: left;
    }
    
    th {
      background: #444;
      color: white;
      cursor: pointer;
      user-select: none;
      position: relative;
    }
    
    th:hover {
      background: #555;
    }
    
    th.sort-asc::after {
      content: ' ▲';
      position: absolute;
      right: 8px;
    }
    
    th.sort-desc::after {
      content: ' ▼';
      position: absolute;
      right: 8px;
    }
    
    /* Zebra striping for table rows */
    tbody tr:nth-child(even) {
      background-color: #f9f9f9;
    }
    
    tbody tr:hover {
      background-color: #e3f2fd;
    }
    
    .status-icon {
      margin-right: 0.5rem;
      font-size: 1.1rem;
    }
    
    /* Progressive loading indicator */
    .loading-indicator {
      display: inline-block;
      width: 12px;
      height: 12px;
      border: 2px solid #f3f3f3;
      border-top: 2px solid #2196f3;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-right: 0.5rem;
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    /* Smooth transitions for progressive loading */
    tbody tr {
      transition: opacity 0.3s ease;
    }
    
    .loading-row {
      opacity: 0.7;
    }
    
    /* Galaxy logo styling in header */
    .header-title {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 1rem;
      margin-bottom: 1rem;
    }
    
    .title-section {
      display: flex;
      align-items: center;
      gap: 1rem;
    }
    
    .galaxy-logo {
      max-width: 150px;
      max-height: 60px;
      height: auto;
      width: auto;
      object-fit: contain;
    }
    
    .header-title h1 {
      margin: 0;
      font-size: 2.5rem;
      color: #333;
    }
    
    /* Improved responsive design */
    @media (max-width: 768px) {
      .header-title {
        flex-direction: column;
        text-align: center;
        gap: 1rem;
      }
      
      .title-section {
        flex-direction: column;
        gap: 0.5rem;
      }
      
      .summary-stats {
        flex-direction: column;
        gap: 1rem;
      }
      
      .stat-box {
        min-width: auto;
      }
      
      table {
        font-size: 0.9rem;
      }
      
      th, td {
        padding: 0.5rem;
      }
      
      .header-title {
        flex-direction: column;
        text-align: center;
        gap: 0.5rem;
      }
      
      .galaxy-logo {
        max-width: 120px;
        max-height: 45px;
      }
      
      .header-title h1 {
        font-size: 1.8rem;
      }
    }
  </style>
</head>
<body>
  <div class="header-section">
    <div class="header-title">
      <div class="title-section">
        <img src="https://galaxyproject.org/images/galaxy-logos/galaxy_project_logo.jpg" alt="Galaxy Project Logo" class="galaxy-logo">
        <h1>Galaxy Server Tracker</h1>
      </div>
      
      <div id="summary-stats" class="summary-stats" style="display: none;">
        <div class="stat-box">
          <div class="stat-number" id="total-servers">0</div>
          <div>Total Servers</div>
        </div>
        <div class="stat-box">
          <div class="stat-number" id="online-servers">0</div>
          <div>Online Servers</div>
        </div>
        <div class="stat-box">
          <div class="stat-number" id="offline-servers">0</div>
          <div>Offline/Unknown</div>
        </div>
      </div>
    </div>
    
    <div class="search-container">
      <input type="text" id="search-input" class="search-input" placeholder="🔍 Search servers by name, URL, location, or any other field...">
    </div>
  </div>
  <table id="galaxy-table">
    <thead>
      <tr>
        <th>Name</th>
        <th>URL</th>
        <th>Location</th>
        <th>Notes</th>
        <th>Contact Name</th>
        <th>Contact Email</th>
        <th>Tier</th>
        <th>Version</th>
        <th>Tool Count</th>
      </tr>
    </thead>
    <tbody></tbody>
  </table>

  <div id="status" style="margin-top: 1rem; padding: 0.75rem; background: #e3f2fd; border: 1px solid #2196f3; border-radius: 4px; text-align: center;">
    Loading data from spreadsheet...
  </div>

  <div class="spreadsheet-link" style="margin-top: 2rem; text-align: center; display: flex; justify-content: center; gap: 2rem; flex-wrap: wrap;">
    <div>📊 <a href="https://docs.google.com/spreadsheets/d/1HSpJ7vOxfnYSjfFm1vs528eydh1gVU40rKR6-1TCeCo/edit#gid=0" target="_blank" style="color: inherit; text-decoration: none;">Source Spreadsheet</a></div>
    <div> | </div>
    <div>🔗 <a href="https://github.com/mschatz/gxyservers" target="_blank" style="color: inherit; text-decoration: none;">GitHub Repository</a></div>
  </div>

  <script>
    const sheetId = '1HSpJ7vOxfnYSjfFm1vs528eydh1gVU40rKR6-1TCeCo';
    
    // Using Google Sheets public CSV endpoint - works well with GitHub Pages
    const sheetUrl = `https://docs.google.com/spreadsheets/d/${sheetId}/export?format=csv&gid=0`;

    // Global variables for sorting and filtering
    let currentData = [];
    let filteredData = [];
    let currentSortColumn = null;
    let currentSortDirection = 'asc';
    
    function getStatusIcon(version) {
      if (version === 'Loading...' || version === 'N/A') return '⏳';
      if (version === 'Offline') return '🔴';
      if (version === 'CORS Blocked') return '🟡';
      if (version === 'Unknown' || version === 'API Error' || version === 'Error') return '🟠';
      return '🟢';
    }
    
    function updateSummaryStats() {
      if (!currentData || currentData.length === 0) return;
      
      const total = currentData.length;
      
      console.log('updateSummaryStats called with data:', currentData.map(row => ({ 
        name: row['Name'], 
        version: row['Version'] 
      })));
      
      const online = currentData.filter(row => {
        const version = row['Version'] || '';
        const isOnline = version && version !== 'Loading...' && version !== 'N/A' && 
               version !== 'Offline' && version !== 'Error' && version !== 'No URL' && 
               version !== 'Local Mode';
        
        console.log(`Server ${row['Name']}: version="${version}", isOnline=${isOnline}`);
        return isOnline;
      }).length;
      
      const offline = total - online;
      
      console.log(`Summary stats: Total=${total}, Online=${online}, Offline=${offline}`);
      
      document.getElementById('total-servers').textContent = total;
      document.getElementById('online-servers').textContent = online;
      document.getElementById('offline-servers').textContent = offline;
      document.getElementById('summary-stats').style.display = 'flex';
    }
    
    function setupSearchFilter() {
      const searchInput = document.getElementById('search-input');
      searchInput.addEventListener('input', (e) => {
        const searchTerm = e.target.value.toLowerCase().trim();
        
        if (searchTerm === '') {
          filteredData = [...currentData];
        } else {
          filteredData = currentData.filter(row => {
            return Object.values(row).some(value => 
              value && value.toString().toLowerCase().includes(searchTerm)
            );
          });
        }
        
        // Re-apply current sort if any
        if (currentSortColumn) {
          sortFilteredData(currentSortColumn, currentSortDirection);
        } else {
          renderTableRows(filteredData);
        }
        
        // Show "no results" message if needed
        if (filteredData.length === 0 && searchTerm !== '') {
          showNoResults();
        }
      });
    }
    
    function showNoResults() {
      const tbody = document.querySelector('#galaxy-table tbody');
      tbody.innerHTML = '<tr><td colspan="9" class="no-results">No servers match your search criteria.</td></tr>';
    }

    function initializeTableSorting() {
      const headers = document.querySelectorAll('#galaxy-table th');
      headers.forEach((header, index) => {
        header.addEventListener('click', () => {
          const columnName = header.textContent.trim();
          sortTable(columnName);
        });
      });
    }

    function sortTable(columnName) {
      if (!currentData || currentData.length === 0) return;

      // Determine sort direction
      if (currentSortColumn === columnName) {
        currentSortDirection = currentSortDirection === 'asc' ? 'desc' : 'asc';
      } else {
        currentSortDirection = 'asc';
        currentSortColumn = columnName;
      }

      // Update header indicators
      const headers = document.querySelectorAll('#galaxy-table th');
      headers.forEach(header => {
        header.classList.remove('sort-asc', 'sort-desc');
        if (header.textContent.trim() === columnName) {
          header.classList.add(currentSortDirection === 'asc' ? 'sort-asc' : 'sort-desc');
        }
      });

      // Sort the filtered data (or all data if no filter)
      const dataToSort = filteredData.length > 0 ? filteredData : currentData;
      sortFilteredData(columnName, currentSortDirection);
    }
    
    function sortFilteredData(columnName, direction) {
      const dataToSort = filteredData.length > 0 ? filteredData : currentData;
      
      const sortedData = [...dataToSort].sort((a, b) => {
        let aVal = a[columnName] || '';
        let bVal = b[columnName] || '';

        // Handle numeric values for Tool Count
        if (columnName === 'Tool Count') {
          const aNum = parseInt(aVal);
          const bNum = parseInt(bVal);
          if (!isNaN(aNum) && !isNaN(bNum)) {
            return direction === 'asc' ? aNum - bNum : bNum - aNum;
          }
        }

        // Handle string comparison
        aVal = aVal.toString().toLowerCase();
        bVal = bVal.toString().toLowerCase();

        if (direction === 'asc') {
          return aVal.localeCompare(bVal);
        } else {
          return bVal.localeCompare(aVal);
        }
      });

      // Update filtered data and re-render
      if (filteredData.length > 0) {
        filteredData = sortedData;
      }
      renderTableRows(sortedData);
    }

    function parseCSV(text) {
      const lines = text.split('\n').filter(line => line.trim());
      if (lines.length === 0) return [];
      
      // Handle CSV parsing with proper quote handling
      function parseCSVLine(line) {
        const result = [];
        let current = '';
        let inQuotes = false;
        
        for (let i = 0; i < line.length; i++) {
          const char = line[i];
          const nextChar = line[i + 1];
          
          if (char === '"') {
            if (inQuotes && nextChar === '"') {
              current += '"';
              i++; // Skip next quote
            } else {
              inQuotes = !inQuotes;
            }
          } else if (char === ',' && !inQuotes) {
            result.push(current.trim());
            current = '';
          } else {
            current += char;
          }
        }
        result.push(current.trim());
        return result;
      }
      
      const headers = parseCSVLine(lines[0]);
      const data = [];
      
      for (let i = 1; i < lines.length; i++) {
        const values = parseCSVLine(lines[i]);
        if (values.length > 1 || values[0]) { // Skip empty rows
          const row = {};
          headers.forEach((header, index) => {
            row[header] = values[index] || '';
          });
          data.push(row);
        }
      }
      
      return data;
    }

    async function loadSpreadsheetData() {
      updateStatus('Loading data from Google Spreadsheet...');
      
      // Check if we're running locally (file:// protocol)
      const isLocalFile = window.location.protocol === 'file:';
      
      if (isLocalFile) {
        console.log('Running from local file - CORS will be blocked. Use a web server for testing.');
        updateStatus('Running from local file. For testing, please use a web server (e.g., python3 -m http.server 8000) or deploy to GitHub Pages.', false);
        renderSampleData();
        return;
      }
      
      try {
        const response = await fetch(sheetUrl, {
          method: 'GET',
          mode: 'cors',
          headers: {
            'Accept': 'text/csv'
          }
        });
        
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const csvText = await response.text();
        console.log('CSV data received:', csvText);
        
        const data = parseCSV(csvText);
        console.log('Parsed data:', data);
        
        if (data.length === 0) {
          throw new Error('No data found in spreadsheet');
        }
        
        renderTable(data);
        
      } catch (error) {
        console.error('Error loading spreadsheet:', error);
        
        // Provide helpful error message for GitHub Pages
        let errorMessage = 'Unable to load data from Google Spreadsheet. ';
        
        if (error.message.includes('CORS')) {
          errorMessage += 'This appears to be a CORS issue. ';
        }
        
        errorMessage += 'For GitHub Pages hosting, please ensure: ';
        errorMessage += '1) The Google Spreadsheet is published to the web (File → Share → Publish to web), ';
        errorMessage += '2) Set sharing to "Anyone on the internet with this link can view", ';
        errorMessage += '3) The spreadsheet has the correct column headers (Name, URL, Location, Notes, Contact Name, Contact Email, Tier).';
        
        updateStatus(errorMessage, true);
        
        // Show sample data for testing
        console.log('Showing sample data for testing...');
        renderSampleData();
      }
    }

    function renderSampleData() {
      updateStatus('Showing sample data for testing purposes...', false);
      
      const sampleData = [
        {
          'Name': 'Sample Galaxy Server',
          'URL': 'https://usegalaxy.org',
          'Location': 'USA',
          'Notes': 'Main Galaxy server',
          'Contact Name': 'Galaxy Team',
          'Contact Email': 'galaxy@example.com',
          'Tier': '1'
        }
      ];
      
      renderTable(sampleData);
    }
    
    // Function to get comprehensive tool count by trying multiple endpoints
    async function getComprehensiveToolCount(cleanUrl, primaryToolsData, configData, corsProxy) {
      console.log(`${cleanUrl}: Starting comprehensive tool count extraction`);
      
      // Try the primary tools data first
      let toolCount = extractToolCountFromData(cleanUrl, primaryToolsData, 'primary');
      
      // If we got a reasonable count, return it (but try to get a better one if it's low)
      if (typeof toolCount === 'number' && toolCount > 5000) {
        console.log(`${cleanUrl}: Primary endpoint gave good count: ${toolCount}`);
        return toolCount;
      }
      
      // If the count is low, try additional endpoints
      const additionalEndpoints = [
        { name: 'installed', url: `${corsProxy}${encodeURIComponent(cleanUrl + '/api/tools?installed=true')}` },
        { name: 'toolbox', url: `${corsProxy}${encodeURIComponent(cleanUrl + '/api/toolbox')}` },
        { name: 'toolshed', url: `${corsProxy}${encodeURIComponent(cleanUrl + '/api/tool_shed_repositories?installed=true')}` }
      ];
      
      let bestCount = toolCount;
      
      for (const endpoint of additionalEndpoints) {
        try {
          console.log(`${cleanUrl}: Trying ${endpoint.name} endpoint`);
          const response = await fetch(endpoint.url, {
            method: 'GET',
            headers: { 'Accept': 'application/json' }
          });
          
          if (response.ok) {
            const data = await response.json();
            const count = extractToolCountFromData(cleanUrl, data, endpoint.name);
            
            if (typeof count === 'number' && count > bestCount) {
              console.log(`${cleanUrl}: ${endpoint.name} endpoint gave better count: ${count}`);
              bestCount = count;
              
              // If we get a really good count, use it
              if (count > 5000) {
                return count;
              }
            }
          } else {
            console.log(`${cleanUrl}: ${endpoint.name} endpoint failed: ${response.status}`);
          }
        } catch (error) {
          console.log(`${cleanUrl}: ${endpoint.name} endpoint error:`, error.message);
        }
      }
      
      // If still low, try config data
      if (typeof bestCount !== 'number' || bestCount < 1000) {
        const configCount = extractToolCountFromData(cleanUrl, configData, 'config');
        if (typeof configCount === 'number' && configCount > bestCount) {
          bestCount = configCount;
        }
      }
      
      console.log(`${cleanUrl}: Final comprehensive tool count: ${bestCount}`);
      return bestCount;
    }
    
    // Function to extract tool count from API response data
    function extractToolCountFromData(cleanUrl, data, source) {
      console.log(`${cleanUrl}: Extracting tool count from ${source} data`);
      
      if (!data || data.error) {
        console.log(`${cleanUrl}: ${source} data has error or is empty`);
        return 'API Error';
      }
      
      // Handle arrays (most common for tools API)
      if (Array.isArray(data)) {
        if (source === 'toolshed') {
          // Tool shed repositories - count total tools in all repos
          let totalTools = 0;
          data.forEach(repo => {
            if (repo.tool_count) {
              totalTools += repo.tool_count;
            } else if (repo.tools && Array.isArray(repo.tools)) {
              totalTools += repo.tools.length;
            } else {
              totalTools += 1; // Assume 1 tool per repo if not specified
            }
          });
          console.log(`${cleanUrl}: ${source} - counted ${totalTools} tools from ${data.length} repositories`);
          return totalTools;
        } else {
          // Regular tools API - count tools in sections with recursive support
          let totalTools = 0;
          
          const countToolsRecursively = (item, sectionName = 'unnamed') => {
            let count = 0;
            
            if (Array.isArray(item)) {
              // Array of items - process each
              item.forEach(subItem => {
                count += countToolsRecursively(subItem, sectionName);
              });
            } else if (item && typeof item === 'object') {
              // Check if this is a direct tool (has ID and no nested structure)
              if (item.id && !item.tools && !item.elems) {
                count = 1;
              } else {
                // This is a section - count tools inside
                if (item.tools && Array.isArray(item.tools)) {
                  count += countToolsRecursively(item.tools, item.name || item.id || sectionName);
                }
                if (item.elems && Array.isArray(item.elems)) {
                  count += countToolsRecursively(item.elems, item.name || item.id || sectionName);
                }
              }
            }
            
            return count;
          };
          
          data.forEach((section, index) => {
            const sectionName = section?.name || section?.id || `section-${index}`;
            const sectionCount = countToolsRecursively(section, sectionName);
            totalTools += sectionCount;
            if (sectionCount > 0) {
              console.log(`${cleanUrl}: ${source} - Section "${sectionName}" has ${sectionCount} tools`);
            }
          });
          
          if (totalTools > 0) {
            console.log(`${cleanUrl}: ${source} - got ${totalTools} tools from ${data.length} sections (recursive count)`);
            return totalTools;
          } else {
            // Fallback: count array items as tools
            console.log(`${cleanUrl}: ${source} - no tools in sections, using array length: ${data.length}`);
            return data.length;
          }
        }
      }
      
      // Handle objects
      if (typeof data === 'object') {
        // Check for direct count fields
        if (data.tool_count) {
          console.log(`${cleanUrl}: ${source} - got ${data.tool_count} from tool_count field`);
          return data.tool_count;
        }
        if (data.total) {
          console.log(`${cleanUrl}: ${source} - got ${data.total} from total field`);
          return data.total;
        }
        if (data.count) {
          console.log(`${cleanUrl}: ${source} - got ${data.count} from count field`);
          return data.count;
        }
        
        // Check for tools array
        if (data.tools && Array.isArray(data.tools)) {
          return extractToolCountFromData(cleanUrl, data.tools, source + '.tools');
        }
        
        console.log(`${cleanUrl}: ${source} - unrecognized object structure:`, Object.keys(data));
      }
      
      console.log(`${cleanUrl}: ${source} - could not extract tool count`);
      return 'Unknown';
    }

    async function fetchGalaxyInfo(url) {
      // Check if we're running locally (file:// protocol)
      const isLocalFile = window.location.protocol === 'file:';
      
      console.log(`fetchGalaxyInfo called for: ${url}, isLocalFile: ${isLocalFile}, protocol: ${window.location.protocol}`);
      
      if (isLocalFile) {
        console.log('Returning local mode for:', url);
        return Promise.resolve({ version: 'Local Mode', toolCount: 'Local Mode' });
      }
      
      // Clean and validate the URL
      let cleanUrl = url.trim();
      if (!cleanUrl) {
        console.log('No URL provided for server');
        return Promise.resolve({ version: 'No URL', toolCount: 'No URL' });
      }
      
      // Remove trailing slash if present
      cleanUrl = cleanUrl.replace(/\/$/, '');
      
      // Ensure URL has protocol
      if (!cleanUrl.startsWith('http://') && !cleanUrl.startsWith('https://')) {
        cleanUrl = 'https://' + cleanUrl;
      }
      
      console.log(`Fetching Galaxy info from: ${cleanUrl}`);
      
      // Use CORS proxy for API calls to bypass CORS restrictions
      const corsProxy = 'https://corsproxy.io/?url=';
      const versionUrl = `${corsProxy}${encodeURIComponent(cleanUrl + '/api/version')}`;
      // Try multiple endpoints to get the most comprehensive tool count
      const toolsUrl = `${corsProxy}${encodeURIComponent(cleanUrl + '/api/tools?all=true&in_panel=false')}`;
      const toolsUrlFallback = `${corsProxy}${encodeURIComponent(cleanUrl + '/api/tools')}`;
      const toolsInstalledUrl = `${corsProxy}${encodeURIComponent(cleanUrl + '/api/tools?installed=true')}`;
      const toolboxUrl = `${corsProxy}${encodeURIComponent(cleanUrl + '/api/toolbox')}`;
      const configUrl = `${corsProxy}${encodeURIComponent(cleanUrl + '/api/configuration')}`;
      const toolshedUrl = `${corsProxy}${encodeURIComponent(cleanUrl + '/api/tool_shed_repositories?installed=true')}`;
      
      // Add timeout to prevent hanging requests
      const fetchWithTimeout = (url, timeout = 15000) => {
        console.log(`Starting fetch for: ${url} with timeout: ${timeout}ms`);
        return Promise.race([
          fetch(url, { 
            method: 'GET',
            headers: {
              'Accept': 'application/json'
            }
          }),
          new Promise((_, reject) => 
            setTimeout(() => reject(new Error('Timeout')), timeout)
          )
        ]);
      };
      
      // Robust server reachability check that tries to distinguish DNS failures from CORS blocks
      const checkServerStatus = async () => {
        console.log(`Checking server status for: ${cleanUrl}`);
        
        // Try multiple approaches to determine if server is reachable
        const tests = [];
        
        // Test 1: Try a simple image request that might bypass some CORS restrictions
        tests.push(
          new Promise(resolve => {
            const img = new Image();
            const timeout = setTimeout(() => {
              resolve({ test: 'image-favicon', success: false, error: 'timeout' });
            }, 3000);
            
            img.onload = () => {
              clearTimeout(timeout);
              resolve({ test: 'image-favicon', success: true });
            };
            
            img.onerror = (e) => {
              clearTimeout(timeout);
              // Even 404s indicate the server is reachable
              resolve({ test: 'image-favicon', success: false, error: 'load-error-but-reachable' });
            };
            
            img.src = cleanUrl + '/favicon.ico?' + Math.random();
          })
        );
        
        // Test 2: Try a no-cors fetch
        tests.push(
          fetch(cleanUrl + '/robots.txt', { mode: 'no-cors', method: 'HEAD' })
            .then(() => ({ test: 'no-cors-robots', success: true }))
            .catch(error => ({ 
              test: 'no-cors-robots', 
              success: false, 
              error: error.message,
              isDnsError: error.message.includes('ERR_NAME_NOT_RESOLVED') || 
                         error.message.includes('ENOTFOUND') ||
                         error.message.includes('DNS')
            }))
        );
        
        // Test 3: Try another static file
        tests.push(
          fetch(cleanUrl + '/static/favicon.svg', { mode: 'no-cors', method: 'HEAD' })
            .then(() => ({ test: 'no-cors-static', success: true }))
            .catch(error => ({ 
              test: 'no-cors-static', 
              success: false, 
              error: error.message,
              isDnsError: error.message.includes('ERR_NAME_NOT_RESOLVED') || 
                         error.message.includes('ENOTFOUND') ||
                         error.message.includes('DNS')
            }))
        );
        
        const results = await Promise.all(tests);
        console.log(`${cleanUrl}: Reachability test results:`, results);
        
        // If any test succeeded, server is reachable
        if (results.some(r => r.success)) {
          console.log(`${cleanUrl}: Server is reachable (at least one test succeeded)`);
          return { reachable: true, corsBlocked: false };
        }
        
        // If any test shows clear DNS errors, server is offline
        if (results.some(r => r.isDnsError)) {
          console.log(`${cleanUrl}: DNS error detected - server is offline`);
          return { reachable: false, corsBlocked: false };
        }
        
        // All tests failed but no clear DNS errors - likely CORS or online but inaccessible
        console.log(`${cleanUrl}: All tests failed without DNS errors - assuming server is online but CORS-blocked`);
        return { reachable: false, corsBlocked: true };
      };
      
      return Promise.all([
        fetchWithTimeout(versionUrl)
          .then(res => {
            console.log(`Version API response for ${cleanUrl}:`, res.status, res.statusText);
            if (res.ok) {
              return res.json();
            } else {
              // CORS proxy will return specific errors for unreachable servers
              if (res.status === 500 || res.status === 502 || res.status === 503 || res.status === 504 || res.status === 530) {
                throw new Error('SERVER_UNREACHABLE');
              }
              throw new Error(`HTTP_${res.status}`);
            }
          })
          .then(versionJson => {
            console.log(`Version API JSON for ${cleanUrl}:`, versionJson);
            return versionJson;
          })
          .catch(err => {
            console.log(`Version API error for ${cleanUrl}:`, err.message);
            return { error: err.message, type: 'version' };
          }),
        fetchWithTimeout(toolsUrl)
          .then(res => {
            console.log(`Tools API response for ${cleanUrl}:`, res.status, res.statusText);
            if (res.ok) {
              return res.json();
            } else {
              // CORS proxy will return specific errors for unreachable servers
              if (res.status === 500 || res.status === 502 || res.status === 503 || res.status === 504 || res.status === 530) {
                throw new Error('SERVER_UNREACHABLE');
              }
              throw new Error(`HTTP_${res.status}`);
            }
          })
          .then(toolsJson => {
            console.log(`Tools API JSON for ${cleanUrl} (type: ${typeof toolsJson}, isArray: ${Array.isArray(toolsJson)}):`, toolsJson);
            // Log the structure to help debug
            if (Array.isArray(toolsJson) && toolsJson.length > 0) {
              console.log(`${cleanUrl}: First section structure:`, toolsJson[0]);
            }
            return toolsJson;
          })
          .catch(err => {
            console.log(`Tools API error for ${cleanUrl}:`, err.message);
            return { error: err.message, type: 'tools' };
          }),
        fetchWithTimeout(configUrl)
          .then(res => {
            console.log(`Config API response for ${cleanUrl}:`, res.status, res.statusText);
            if (res.ok) {
              return res.json();
            } else {
              throw new Error(`HTTP_${res.status}`);
            }
          })
          .then(configJson => {
            console.log(`Config API JSON for ${cleanUrl}:`, configJson);
            return configJson;
          })
          .catch(err => {
            console.log(`Config API error for ${cleanUrl}:`, err.message);
            return { error: err.message, type: 'config' };
          }),
        checkServerStatus()
      ]).then(async ([versionData, toolsData, configData, serverStatus]) => {
        console.log(`Galaxy info for ${cleanUrl}:`, { versionData, toolsData, configData, serverStatus });
        
        // Check for server unreachable errors from the CORS proxy
        const versionError = versionData?.error || '';
        const toolsError = toolsData?.error || '';
        const configError = configData?.error || '';
        
        // Check for DNS/network errors (now indicated by CORS proxy errors)
        const hasServerError = versionError.includes('SERVER_UNREACHABLE') || 
                              toolsError.includes('SERVER_UNREACHABLE') ||
                              versionError.includes('ERR_NAME_NOT_RESOLVED') || 
                              toolsError.includes('ERR_NAME_NOT_RESOLVED') ||
                              versionError.includes('ENOTFOUND') || 
                              toolsError.includes('ENOTFOUND');
        
        const hasTimeoutError = versionError === 'Timeout' || toolsError === 'Timeout';
        
        // Primary check: Look for server unreachable errors from CORS proxy or DNS errors
        if (hasServerError) {
          console.log(`${cleanUrl}: Server unreachable via CORS proxy - server is offline`);
          return { version: 'Offline', toolCount: 'Offline' };
        }
        
        // If timeout errors occur and static file tests also indicate unreachable, likely offline
        if (hasTimeoutError && !serverStatus.reachable && !serverStatus.corsBlocked) {
          console.log(`${cleanUrl}: Timeout errors and server tests indicate unreachable - server is offline`);
          return { version: 'Offline', toolCount: 'Offline' };
        }
        
        // If we have successful API data from CORS proxy, server is definitely online
        if (versionData && !versionData.error) {
          // Extract version - try different possible fields
          let version = 'Unknown';
          if (versionData.version_major && versionData.version_minor) {
            version = `${versionData.version_major}.${versionData.version_minor}`;
            if (versionData.version_micro) {
              version += `.${versionData.version_micro}`;
            }
          } else if (versionData.version) {
            version = versionData.version;
          } else if (versionData.galaxy_version) {
            version = versionData.galaxy_version;
          }
          
          // Get comprehensive tool count using multiple endpoints
          const toolCount = await getComprehensiveToolCount(cleanUrl, toolsData, configData, corsProxy);
          
          const result = {
            version: version,
            toolCount: toolCount
          };
          console.log(`${cleanUrl}: Successfully got Galaxy info via CORS proxy:`, result);
          return result;
        }
        
        // If static file tests indicate server is unreachable without CORS issues, it's offline
        if (!serverStatus.reachable && !serverStatus.corsBlocked) {
          console.log(`${cleanUrl}: Server tests indicate unreachable - server is offline`);
          return { version: 'Offline', toolCount: 'Offline' };
        }
        
        // If we get here, we have mixed results - server might be online but with API issues
        if (serverStatus.reachable || serverStatus.corsBlocked) {
          console.log(`${cleanUrl}: Server appears reachable but API calls failed - treating as API error`);
          const result = {
            version: versionData?.version || (versionData?.error ? 'API Error' : 'Unknown'),
            toolCount: (Array.isArray(toolsData) ? toolsData.length : toolsData?.length) || (toolsData?.error ? 'API Error' : 'Unknown')
          };
          return result;
        }
        
        // Default case: unable to determine conclusively
        console.log(`${cleanUrl}: Unable to determine status conclusively - treating as unknown`);
        return { version: 'Unknown', toolCount: 'Unknown' };
      });
    }

    function updateStatus(message, isError = false) {
      const statusDiv = document.getElementById('status');
      statusDiv.textContent = message;
      statusDiv.style.background = isError ? '#ffebee' : '#e3f2fd';
      statusDiv.style.borderColor = isError ? '#f44336' : '#2196f3';
    }

    function renderTable(data) {
      if (!data || data.length === 0) {
        updateStatus('No data found in the spreadsheet or unable to access it.', true);
        return;
      }

      console.log('Rendering table with data:', data);
      updateStatus(`Found ${data.length} server(s) in the spreadsheet. Loading Galaxy API data...`);
      
      // Store data globally for sorting and filtering
      currentData = data;
      filteredData = [...data]; // Initialize filtered data
      
      // Initialize sorting functionality
      initializeTableSorting();
      
      // Initialize search filter
      setupSearchFilter();
      
      // Show initial loading state with status icons
      renderTableRows(currentData);
      updateSummaryStats();
      
      // Fetch Galaxy info for all servers ONCE
      fetchAllGalaxyInfo(data).then(() => {
        // After all API calls are done, render the table again with updated data
        renderTableRows(filteredData.length > 0 ? filteredData : currentData);
        updateStatus(`Loaded ${data.length} server(s). Galaxy API data fetched successfully.`);
        updateSummaryStats();
      });
    }

    async function fetchAllGalaxyInfo(data) {
      let completedCount = 0;
      const totalCount = data.length;
      
      console.log(`Starting fetchAllGalaxyInfo for ${totalCount} servers`);
      
      const updateProgress = () => {
        completedCount++;
        updateStatus(`Loading Galaxy API data... (${completedCount}/${totalCount} completed)`);
        
        // Re-render table to show progressive updates
        renderTableRows(filteredData.length > 0 ? filteredData : currentData);
        updateSummaryStats();
      };
      
      const promises = data.map(async (row, index) => {
        const url = row['URL'] || row['url'] || '';
        console.log(`Processing server ${index + 1}/${totalCount}: ${row['Name']} - ${url}`);
        
        if (url && url.trim()) {
          try {
            const info = await fetchGalaxyInfo(url.trim());
            // Store the API results directly in the data object
            row['Version'] = info.version;
            row['Tool Count'] = info.toolCount;
            console.log(`Galaxy API completed for ${url.trim()}:`, info);
          } catch (error) {
            console.error(`Error fetching Galaxy info for ${url.trim()}:`, error);
            row['Version'] = 'Error';
            row['Tool Count'] = 'Error';
          }
        } else {
          console.log(`No URL provided for server: ${row['Name']}`);
          row['Version'] = 'N/A';
          row['Tool Count'] = 'N/A';
        }
        
        console.log(`Final status for ${row['Name']}: Version=${row['Version']}, ToolCount=${row['Tool Count']}`);
        
        // Update progress and re-render after each completion
        updateProgress();
      });

      // Wait for all API calls to complete
      await Promise.all(promises);
      console.log('All Galaxy API calls completed');
      console.log('Final data state:', currentData.map(row => ({ name: row['Name'], version: row['Version'], toolCount: row['Tool Count'] })));
    }

    function renderTableRows(data) {
      const tbody = document.querySelector('#galaxy-table tbody');
      tbody.innerHTML = ''; // Clear existing rows
      
      if (!data || data.length === 0) {
        showNoResults();
        return;
      }
      
      data.forEach((row, index) => {
        const tr = document.createElement('tr');
        
        // Name column
        const tdName = document.createElement('td');
        tdName.textContent = row['Name'] || '';
        
        // URL column
        const tdUrl = document.createElement('td');
        const url = row['URL'] || row['url'] || '';
        
        if (url && url.trim()) {
          // Ensure URL has proper protocol for display
          let displayUrl = url.trim();
          if (!displayUrl.startsWith('http://') && !displayUrl.startsWith('https://')) {
            displayUrl = 'https://' + displayUrl;
          }
          tdUrl.innerHTML = `<a href="${displayUrl}" target="_blank">${url.trim()}</a>`;
        } else {
          tdUrl.textContent = 'No URL provided';
        }
        
        // Location column
        const tdLocation = document.createElement('td');
        tdLocation.textContent = row['Location'] || '';
        
        // Notes column
        const tdNotes = document.createElement('td');
        tdNotes.textContent = row['Notes'] || '';
        
        // Contact Name column
        const tdContactName = document.createElement('td');
        tdContactName.textContent = row['Contact Name'] || '';
        
        // Contact Email column
        const tdContactEmail = document.createElement('td');
        const email = row['Contact Email'] || '';
        if (email && email.trim()) {
          tdContactEmail.innerHTML = `<a href="mailto:${email.trim()}">${email.trim()}</a>`;
        } else {
          tdContactEmail.textContent = '';
        }
        
        // Tier column
        const tdTier = document.createElement('td');
        tdTier.textContent = row['Tier'] || '';
        
        // Version column with status icon
        const tdVersion = document.createElement('td');
        const version = row['Version'] || 'Loading...';
        const statusIcon = getStatusIcon(version);
        
        if (version === 'Loading...') {
          tdVersion.innerHTML = `<span class="loading-indicator"></span> ${version}`;
        } else {
          tdVersion.innerHTML = `<span class="status-icon">${statusIcon}</span>${version}`;
        }
        
        // Tool Count column
        const tdToolCount = document.createElement('td');
        const toolCount = row['Tool Count'] || 'Loading...';
        
        if (toolCount === 'Loading...') {
          tdToolCount.innerHTML = `<span class="loading-indicator"></span> ${toolCount}`;
        } else {
          tdToolCount.textContent = toolCount;
        }
        
        // Apply color coding based on version status
        if (version === 'Offline') {
          tdVersion.style.color = '#f44336';
          tdToolCount.style.color = '#f44336';
        } else if (version === 'CORS Blocked') {
          tdVersion.style.color = '#ff9800';
          tdToolCount.style.color = '#ff9800';
          tdVersion.title = 'Server appears online but API calls blocked by browser CORS policy. Will work when deployed to GitHub Pages.';
          tdToolCount.title = 'Server appears online but API calls blocked by browser CORS policy. Will work when deployed to GitHub Pages.';
        } else if (version === 'Unknown' || version === 'API Error' || version === 'Error') {
          tdVersion.style.color = '#ff9800';
          tdToolCount.style.color = '#ff9800';
        } else if (version === 'Loading...' || version === 'N/A') {
          tdVersion.style.color = '#999';
          tdToolCount.style.color = '#999';
        } else {
          tdVersion.style.color = '#4caf50';
          tdToolCount.style.color = '#4caf50';
        }
        
        // Add loading class for progressive update effect
        if (version === 'Loading...' || toolCount === 'Loading...') {
          tr.classList.add('loading-row');
        }
        
        tr.appendChild(tdName);
        tr.appendChild(tdUrl);
        tr.appendChild(tdLocation);
        tr.appendChild(tdNotes);
        tr.appendChild(tdContactName);
        tr.appendChild(tdContactEmail);
        tr.appendChild(tdTier);
        tr.appendChild(tdVersion);
        tr.appendChild(tdToolCount);
        tbody.appendChild(tr);
      });
    }

    window.addEventListener('DOMContentLoaded', () => {
      loadSpreadsheetData();
    });
  </script>
</body>
</html>

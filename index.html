<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Galaxy Server Tracker</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
  <style>
    body {
      font-family: sans-serif;
      padding: 2rem;
      background: #f4f4f4;
    }
    
    .header-section {
      background: #fff;
      padding: 1.5rem;
      margin-bottom: 1rem;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    
    .summary-stats {
      display: flex;
      gap: 1.5rem;
      font-size: 1rem;
    }
    
    .stat-box {
      background: #e3f2fd;
      padding: 0.75rem;
      border-radius: 6px;
      text-align: center;
      min-width: 100px;
    }
    
    .stat-number {
      font-size: 1.2rem;
      font-weight: bold;
      color: #1976d2;
    }
    
    .spreadsheet-link {
      margin: 1rem 0;
      padding: 0.75rem;
      background: #f5f5f5;
      border-radius: 4px;
    }
    
    .search-container {
      margin: 1rem 0;
    }
    
    .search-input {
      width: 100%;
      padding: 0.75rem;
      border: 1px solid #ccc;
      border-radius: 4px;
      font-size: 1rem;
      box-sizing: border-box;
    }
    
    .search-input:focus {
      border-color: #2196f3;
      outline: none;
      box-shadow: 0 0 0 2px rgba(33, 150, 243, 0.2);
    }
    
    table {
      width: 100%;
      border-collapse: collapse;
      background: #fff;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    
    th, td {
      padding: 0.75rem;
      border: 1px solid #ccc;
      text-align: left;
    }
    
    /* Set column widths */
    th:nth-child(1), td:nth-child(1) { /* Status column */
      width: 50px;
      max-width: 50px;
    }
    
    th:nth-child(2), td:nth-child(2) { /* Tier column */
      width: 50px;
      max-width: 50px;
    }
    
    th:nth-child(3), td:nth-child(3) { /* Name column */
      width: 240px;
      max-width: 240px;
    }
    
    th:nth-child(4), td:nth-child(4) { /* Region column */
      width: 100px;
      max-width: 100px;
    }
    
    th {
      background: #444;
      color: white;
      cursor: pointer;
      user-select: none;
      position: relative;
    }
    
    /* Center align the status and tier column headers */
    th:nth-child(1), th:nth-child(2) {
      text-align: center;
    }
    
    /* Center align Info, Server, and Resources column headers */
    th:nth-child(6), th:nth-child(7), th:nth-child(8) {
      text-align: center;
    }
    
    /* Server column styling for multi-line content */
    td:nth-child(7) {
      line-height: 1.3;
      vertical-align: top;
    }
    
    /* Resources column styling for multi-line content */
    td:nth-child(8) {
      line-height: 1.3;
      vertical-align: top;
    }
    
    th:hover {
      background: #555;
    }
    
    th.sort-asc::after {
      content: ' ▲';
      position: absolute;
      right: 8px;
    }
    
    th.sort-desc::after {
      content: ' ▼';
      position: absolute;
      right: 8px;
    }
    
    /* Zebra striping for table rows */
    tbody tr:nth-child(even) {
      background-color: #f9f9f9;
    }
    
    tbody tr:hover {
      background-color: #e3f2fd;
    }
    
    .status-icon {
      margin-right: 0.5rem;
      font-size: 1.1rem;
    }
    
    /* Progressive loading indicator */
    .loading-indicator {
      display: inline-block;
      width: 12px;
      height: 12px;
      border: 2px solid #f3f3f3;
      border-top: 2px solid #2196f3;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-right: 0.5rem;
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    /* Smooth transitions for progressive loading */
    tbody tr {
      transition: opacity 0.3s ease;
    }
    
    .loading-row {
      opacity: 0.7;
    }
    
    /* Galaxy logo styling in header */
    .header-title {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 1rem;
      margin-bottom: 1rem;
    }
    
    .title-section {
      display: flex;
      align-items: center;
      gap: 1rem;
    }
    
    .galaxy-logo {
      max-width: 150px;
      max-height: 60px;
      height: auto;
      width: auto;
      object-fit: contain;
    }
    
    .header-title h1 {
      margin: 0;
      font-size: 2.5rem;
      color: #333;
    }
    
    /* Server favicon styling */
    .server-favicon {
      width: 16px;
      height: 16px;
      margin-right: 0.5rem;
      vertical-align: middle;
      border-radius: 2px;
    }
    
    .server-name-container {
      display: flex;
      align-items: center;
    }
    
    .server-name-info {
      display: flex;
      flex-direction: column;
      gap: 0.25rem;
    }
    
    .server-url {
      font-size: 0.85em;
      color: #666;
      text-decoration: none;
    }
    
    .server-url:hover {
      color: #2196f3;
      text-decoration: underline;
    }
    
    .institution-info {
      display: flex;
      flex-direction: column;
      gap: 0.1rem;
    }
    
    .institution-notes {
      font-size: 0.85em;
      color: #666;
      font-style: italic;
      margin-top: 0.1rem;
    }
    
    /* Info field styling */
    .contact-container {
      line-height: 1.4;
    }
    
    .contact-name {
      font-weight: 500;
      margin-bottom: 2px;
    }
    
    .contact-email {
      font-size: 0.9em;
      color: #666;
    }
    
    /* Links/Info icons styling */
    .contact-icons {
      display: flex;
      gap: 0.75rem;
      justify-content: center;
      align-items: center;
    }
    
    .contact-icon {
      color: #666;
      font-size: 1.1rem;
      text-decoration: none;
      transition: color 0.2s ease;
    }
    
    .contact-icon:hover {
      color: #2196f3;
    }
    
    .contact-icon.disabled {
      color: #ccc;
      cursor: not-allowed;
    }
    
    .no-results {
      text-align: center;
      font-style: italic;
      color: #666;
      padding: 2rem !important;
    }
    
    /* Improved responsive design */
    @media (max-width: 768px) {
      .header-title {
        flex-direction: column;
        text-align: center;
        gap: 1rem;
      }
      
      .title-section {
        flex-direction: column;
        gap: 0.5rem;
      }
      
      .summary-stats {
        flex-direction: column;
        gap: 1rem;
      }
      
      .stat-box {
        min-width: auto;
      }
      
      table {
        font-size: 0.9rem;
      }
      
      th, td {
        padding: 0.5rem;
      }
      
      .header-title {
        flex-direction: column;
        text-align: center;
        gap: 0.5rem;
      }
      
      .galaxy-logo {
        max-width: 120px;
        max-height: 45px;
      }
      
      .header-title h1 {
        font-size: 1.8rem;
      }
    }
  </style>
</head>
<body>
  <div class="header-section">
    <div class="header-title">
      <div class="title-section">
        <img src="https://galaxyproject.org/images/galaxy-logos/galaxy_project_logo_square_no_text_trans.png" alt="Galaxy Project Logo" class="galaxy-logo">
        <h1>Galaxy Server Tracker</h1>
      </div>
      
      <div id="summary-stats" class="summary-stats" style="display: none;">
        <div class="stat-box">
          <div class="stat-number" id="total-servers">0</div>
          <div>Total Servers</div>
        </div>
        <div class="stat-box">
          <div class="stat-number" id="online-servers">0</div>
          <div>Online Servers</div>
        </div>
        <div class="stat-box">
          <div class="stat-number" id="offline-servers">0</div>
          <div>Offline/Unknown</div>
        </div>
      </div>
    </div>
    
    <div class="search-container">
      <input type="text" id="search-input" class="search-input" placeholder="🔍 Search servers by name, URL, region, or any other field...">
      <div style="margin-top: 0.75rem; display: flex; align-items: center; gap: 0.5rem;">
        <input type="checkbox" id="hide-offline-checkbox">
        <label for="hide-offline-checkbox" style="font-size: 0.9rem; cursor: pointer;">Hide offline servers</label>
      </div>
    </div>
  </div>
  <table id="galaxy-table">
    <thead>
      <tr>
        <th><i class="fas fa-signal" title="Status" style="color: green;"></i></th>
        <th><i class="fas fa-star" title="Tier" style="color: gold;"></i></th>
        <th>Name</th>
        <th>Region</th>
        <th>Institution</th>
        <th>Info</th>
        <th>Server</th>
        <th title="Available tools and genomes">Resources</th>
      </tr>
    </thead>
    <tbody></tbody>
  </table>

  <div id="status" style="margin-top: 1rem; padding: 0.75rem; background: #e3f2fd; border: 1px solid #2196f3; border-radius: 4px; text-align: center;">
    Loading data from spreadsheet...
  </div>

  <div class="spreadsheet-link" style="margin-top: 1rem; text-align: center; display: flex; justify-content: center; gap: 2rem; flex-wrap: wrap;">
    <div>📊 <a href="https://docs.google.com/spreadsheets/d/1HSpJ7vOxfnYSjfFm1vs528eydh1gVU40rKR6-1TCeCo/edit#gid=0" target="_blank" style="color: inherit; text-decoration: none;">Source Spreadsheet</a></div>
    <div> | </div>
    <div>🔗 <a href="https://github.com/mschatz/gxyservers" target="_blank" style="color: inherit; text-decoration: none;">GitHub Repository</a></div>
  </div>

  <script>
    const sheetId = '1HSpJ7vOxfnYSjfFm1vs528eydh1gVU40rKR6-1TCeCo';
    
    // Using Google Sheets public CSV endpoint - works well with GitHub Pages
    const sheetUrl = `https://docs.google.com/spreadsheets/d/${sheetId}/export?format=csv&gid=0`;

    // Global variables for sorting and filtering
    let currentData = [];
    let filteredData = [];
    let currentSortColumn = null;
    let currentSortDirection = 'asc';
    
    // Function to parse markdown-style links [text](url) and convert to HTML
    function parseMarkdownLinks(text) {
      if (!text || typeof text !== 'string') {
        return text || '';
      }
      
      // Regular expression to match markdown links: [text](url)
      const markdownLinkRegex = /\[([^\]]+)\]\(([^)]+)\)/g;
      
      // Replace all markdown links with HTML anchor tags
      return text.replace(markdownLinkRegex, (match, linkText, url) => {
        // Ensure URL has protocol
        let cleanUrl = url.trim();
        if (!cleanUrl.startsWith('http://') && !cleanUrl.startsWith('https://')) {
          cleanUrl = 'https://' + cleanUrl;
        }
        
        return `<a href="${cleanUrl}" target="_blank" style="color: #2196f3; text-decoration: none;">${linkText.trim()}</a>`;
      });
    }
    
    // Function to format server start time from configuration data
    function formatServerStartTime(serverStartTime) {
      if (!serverStartTime) return '';
      
      try {
        // Parse the server start time (usually in ISO format or timestamp)
        const date = new Date(serverStartTime);
        
        // Check if the date is valid
        if (isNaN(date.getTime())) return '';
        
        // Format as a readable date
        return date.toLocaleDateString('en-US', {
          year: 'numeric',
          month: 'short',
          day: 'numeric'
        });
      } catch (error) {
        console.log('Error parsing server start time:', error);
        return '';
      }
    }
    
    function getStatusIcon(version) {
      if (version === 'Loading...' || version === 'N/A') return { icon: '⏳', tooltip: 'Status unknown or loading...' };
      if (version === 'Offline') return { icon: '🔴', tooltip: 'Server is offline or unreachable' };
      if (version === 'CORS Blocked') return { icon: '🟡', tooltip: 'Server appears online but API calls are blocked' };
      if (version === 'Unknown' || version === 'API Error' || version === 'Error') return { icon: '🟠', tooltip: 'Server status unknown due to API errors' };
      return { icon: '🟢', tooltip: 'Server is online and responding' };
    }
    
    function updateSummaryStats() {
      if (!currentData || currentData.length === 0) return;
      
      const total = currentData.length;
      
      console.log('updateSummaryStats called with data:', currentData.map(row => ({ 
        name: row['Name'], 
        version: row['Version'] 
      })));
      
      const online = currentData.filter(row => {
        const version = row['Version'] || '';
        const isOnline = version && version !== 'Loading...' && version !== 'N/A' && 
               version !== 'Offline' && version !== 'Error' && version !== 'No URL' && 
               version !== 'Local Mode';
        
        console.log(`Server ${row['Name']}: version="${version}", isOnline=${isOnline}`);
        return isOnline;
      }).length;
      
      const offline = total - online;
      
      console.log(`Summary stats: Total=${total}, Online=${online}, Offline=${offline}`);
      
      document.getElementById('total-servers').textContent = total;
      document.getElementById('online-servers').textContent = online;
      document.getElementById('offline-servers').textContent = offline;
      document.getElementById('summary-stats').style.display = 'flex';
    }
    
    function setupSearchFilter() {
      const searchInput = document.getElementById('search-input');
      const hideOfflineCheckbox = document.getElementById('hide-offline-checkbox');
      
      const performFilter = () => {
        const searchTerm = searchInput.value.toLowerCase().trim();
        const hideOffline = hideOfflineCheckbox.checked;
        
        let filtered = [...currentData];
        
        // Apply search filter
        if (searchTerm !== '') {
          filtered = filtered.filter(row => {
            return Object.values(row).some(value => 
              value && value.toString().toLowerCase().includes(searchTerm)
            );
          });
        }
        
        // Apply offline filter
        if (hideOffline) {
          filtered = filtered.filter(row => {
            const version = row['Version'] || '';
            return version !== 'Offline' && version !== 'Error' && version !== 'N/A' && version !== 'No URL';
          });
        }
        
        filteredData = filtered;
        
        // Re-apply current sort if any
        if (currentSortColumn) {
          sortFilteredData(currentSortColumn, currentSortDirection);
        } else {
          renderTableRows(filteredData);
        }
        
        // Show "no results" message if needed
        if (filteredData.length === 0 && (searchTerm !== '' || hideOffline)) {
          showNoResults();
        }
      };
      
      searchInput.addEventListener('input', performFilter);
      hideOfflineCheckbox.addEventListener('change', performFilter);
    }
    
    function showNoResults() {
      const tbody = document.querySelector('#galaxy-table tbody');
      tbody.innerHTML = '<tr><td colspan="8" class="no-results">No servers match your search criteria.</td></tr>';
    }

    function initializeTableSorting() {
      const headers = document.querySelectorAll('#galaxy-table th');
      const columnNames = ['Status', 'Tier', 'Name', 'Region', 'Institution', 'Info', 'Server', 'Resources'];
      
      headers.forEach((header, index) => {
        header.addEventListener('click', () => {
          // Use the predefined column name based on the header index
          const columnName = columnNames[index];
          if (columnName) {
            sortTable(columnName);
          }
        });
      });
    }

    function sortTable(columnName) {
      if (!currentData || currentData.length === 0) return;

      // Determine sort direction
      if (currentSortColumn === columnName) {
        currentSortDirection = currentSortDirection === 'asc' ? 'desc' : 'asc';
      } else {
        currentSortDirection = 'asc';
        currentSortColumn = columnName;
      }

      // Update header indicators
      const headers = document.querySelectorAll('#galaxy-table th');
      const columnNames = ['Status', 'Tier', 'Name', 'Region', 'Institution', 'Info', 'Server', 'Resources'];
      
      headers.forEach((header, index) => {
        header.classList.remove('sort-asc', 'sort-desc');
        if (columnNames[index] === columnName) {
          header.classList.add(currentSortDirection === 'asc' ? 'sort-asc' : 'sort-desc');
        }
      });

      // Sort the filtered data (or all data if no filter)
      const dataToSort = filteredData.length > 0 ? filteredData : currentData;
      sortFilteredData(columnName, currentSortDirection);
    }
    
    function sortFilteredData(columnName, direction) {
      const dataToSort = filteredData.length > 0 ? filteredData : currentData;
      
      const sortedData = [...dataToSort].sort((a, b) => {
        let aVal, bVal;
        
        // Handle special column mappings
        if (columnName === 'Status') {
          // Sort by Version field for status
          aVal = a['Version'] || '';
          bVal = b['Version'] || '';
        } else if (columnName === 'Info') {
          // Sort by contact name or email for info column
          aVal = a['Contact Name'] || a['Contact Email'] || '';
          bVal = b['Contact Name'] || b['Contact Email'] || '';
        } else if (columnName === 'Resources') {
          // Sort by Tool Count field for resources column
          aVal = a['Tool Count'] || '';
          bVal = b['Tool Count'] || '';
        } else {
          aVal = a[columnName] || '';
          bVal = b[columnName] || '';
        }

        // Handle numeric values for Resources and Tier
        if (columnName === 'Resources' || columnName === 'Tier') {
          const aNum = parseInt(aVal);
          const bNum = parseInt(bVal);
          if (!isNaN(aNum) && !isNaN(bNum)) {
            return direction === 'asc' ? aNum - bNum : bNum - aNum;
          }
        }

        // Handle string comparison
        aVal = aVal.toString().toLowerCase();
        bVal = bVal.toString().toLowerCase();

        if (direction === 'asc') {
          return aVal.localeCompare(bVal);
        } else {
          return bVal.localeCompare(aVal);
        }
      });

      // Update filtered data and re-render
      if (filteredData.length > 0) {
        filteredData = sortedData;
      }
      renderTableRows(sortedData);
    }

    function parseCSV(text) {
      const lines = text.split('\n').filter(line => line.trim());
      if (lines.length === 0) return [];
      
      // Handle CSV parsing with proper quote handling
      function parseCSVLine(line) {
        const result = [];
        let current = '';
        let inQuotes = false;
        
        for (let i = 0; i < line.length; i++) {
          const char = line[i];
          const nextChar = line[i + 1];
          
          if (char === '"') {
            if (inQuotes && nextChar === '"') {
              current += '"';
              i++; // Skip next quote
            } else {
              inQuotes = !inQuotes;
            }
          } else if (char === ',' && !inQuotes) {
            result.push(current.trim());
            current = '';
          } else {
            current += char;
          }
        }
        result.push(current.trim());
        return result;
      }
      
      const headers = parseCSVLine(lines[0]);
      const data = [];
      
      for (let i = 1; i < lines.length; i++) {
        const values = parseCSVLine(lines[i]);
        if (values.length > 1 || values[0]) { // Skip empty rows
          const row = {};
          headers.forEach((header, index) => {
            row[header] = values[index] || '';
          });
          data.push(row);
        }
      }
      
      return data;
    }

    async function loadSpreadsheetData() {
      updateStatus('Loading data from Google Spreadsheet...');
      
      // Check if we're running locally (file:// protocol)
      const isLocalFile = window.location.protocol === 'file:';
      
      if (isLocalFile) {
        console.log('Running from local file - CORS will be blocked. Use a web server for testing.');
        updateStatus('Running from local file. For testing, please use a web server (e.g., python3 -m http.server 8000) or deploy to GitHub Pages.', false);
        renderSampleData();
        return;
      }
      
      try {
        const response = await fetch(sheetUrl, {
          method: 'GET',
          mode: 'cors',
          headers: {
            'Accept': 'text/csv'
          }
        });
        
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const csvText = await response.text();
        console.log('CSV data received:', csvText);
        
        const data = parseCSV(csvText);
        console.log('Parsed data:', data);
        
        if (data.length === 0) {
          throw new Error('No data found in spreadsheet');
        }
        
        renderTable(data);
        
      } catch (error) {
        console.error('Error loading spreadsheet:', error);
        
        // Provide helpful error message for GitHub Pages
        let errorMessage = 'Unable to load data from Google Spreadsheet. ';
        
        if (error.message.includes('CORS')) {
          errorMessage += 'This appears to be a CORS issue. ';
        }
        
        errorMessage += 'For GitHub Pages hosting, please ensure: ';
        errorMessage += '1) The Google Spreadsheet is published to the web (File → Share → Publish to web), ';
        errorMessage += '2) Set sharing to "Anyone on the internet with this link can view", ';
        errorMessage += '3) The spreadsheet has the correct column headers (Tier, Name, URL, Region, Institution, Notes).';
        
        updateStatus(errorMessage, true);
        
        // Show sample data for testing
        console.log('Showing sample data for testing...');
        renderSampleData();
      }
    }

    function renderSampleData() {
      updateStatus('Showing sample data for testing purposes...', false);
      
      const sampleData = [
        {
          'Name': 'Sample Galaxy Server',
          'URL': 'https://usegalaxy.org',
          'Region': 'USA',
          'Notes': 'Main Galaxy server',
          'Contact Name': 'Galaxy Team',
          'Contact Email': 'galaxy@example.com',
          'Tier': '1',
          'ConfigData': {
            'support_url': 'https://help.galaxyproject.org',
            'mailing_join_addr': 'galaxy-announce-join@lists.galaxyproject.org',
            'citation_url': 'https://galaxyproject.org/citing-galaxy'
          }
        }
      ];
      
      renderTable(sampleData);
    }
    
    // Function to get comprehensive tool count by trying multiple endpoints
    async function getComprehensiveToolCount(cleanUrl, primaryToolsData, configData, corsProxy) {
      console.log(`${cleanUrl}: Starting comprehensive tool count extraction`);
      
      // Try the primary tools data first
      let toolCount = extractToolCountFromData(cleanUrl, primaryToolsData, 'primary');
      
      // If we got a reasonable count, return it (but try to get a better one if it's low)
      if (typeof toolCount === 'number' && toolCount > 5000) {
        console.log(`${cleanUrl}: Primary endpoint gave good count: ${toolCount}`);
        return toolCount;
      }
      
      // If the count is low, try additional endpoints
      const additionalEndpoints = [
        { name: 'installed', url: `${corsProxy}${encodeURIComponent(cleanUrl + '/api/tools?installed=true')}` },
        { name: 'toolbox', url: `${corsProxy}${encodeURIComponent(cleanUrl + '/api/toolbox')}` },
        { name: 'toolshed', url: `${corsProxy}${encodeURIComponent(cleanUrl + '/api/tool_shed_repositories?installed=true')}` }
      ];
      
      let bestCount = toolCount;
      
      for (const endpoint of additionalEndpoints) {
        try {
          console.log(`${cleanUrl}: Trying ${endpoint.name} endpoint`);
          const response = await fetch(endpoint.url, {
            method: 'GET',
            headers: { 'Accept': 'application/json' }
          });
          
          if (response.ok) {
            const data = await response.json();
            const count = extractToolCountFromData(cleanUrl, data, endpoint.name);
            
            if (typeof count === 'number' && count > bestCount) {
              console.log(`${cleanUrl}: ${endpoint.name} endpoint gave better count: ${count}`);
              bestCount = count;
              
              // If we get a really good count, use it
              if (count > 5000) {
                return count;
              }
            }
          } else {
            console.log(`${cleanUrl}: ${endpoint.name} endpoint failed: ${response.status}`);
          }
        } catch (error) {
          console.log(`${cleanUrl}: ${endpoint.name} endpoint error:`, error.message);
        }
      }
      
      // If still low, try config data
      if (typeof bestCount !== 'number' || bestCount < 1000) {
        const configCount = extractToolCountFromData(cleanUrl, configData, 'config');
        if (typeof configCount === 'number' && configCount > bestCount) {
          bestCount = configCount;
        }
      }
      
      console.log(`${cleanUrl}: Final comprehensive tool count: ${bestCount}`);
      return bestCount;
    }
    
    // Function to extract tool count from API response data
    function extractToolCountFromData(cleanUrl, data, source) {
      console.log(`${cleanUrl}: Extracting tool count from ${source} data`);
      
      if (!data || data.error) {
        console.log(`${cleanUrl}: ${source} data has error or is empty`);
        return 'API Error';
      }
      
      // Handle arrays (most common for tools API)
      if (Array.isArray(data)) {
        if (source === 'toolshed') {
          // Tool shed repositories - count total tools in all repos
          let totalTools = 0;
          data.forEach(repo => {
            if (repo.tool_count) {
              totalTools += repo.tool_count;
            } else if (repo.tools && Array.isArray(repo.tools)) {
              totalTools += repo.tools.length;
            } else {
              totalTools += 1; // Assume 1 tool per repo if not specified
            }
          });
          console.log(`${cleanUrl}: ${source} - counted ${totalTools} tools from ${data.length} repositories`);
          return totalTools;
        } else {
          // Regular tools API - count tools in sections with recursive support
          let totalTools = 0;
          
          const countToolsRecursively = (item, sectionName = 'unnamed') => {
            let count = 0;
            
            if (Array.isArray(item)) {
              // Array of items - process each
              item.forEach(subItem => {
                count += countToolsRecursively(subItem, sectionName);
              });
            } else if (item && typeof item === 'object') {
              // Check if this is a direct tool (has ID and no nested structure)
              if (item.id && !item.tools && !item.elems) {
                count = 1;
              } else {
                // This is a section - count tools inside
                if (item.tools && Array.isArray(item.tools)) {
                  count += countToolsRecursively(item.tools, item.name || item.id || sectionName);
                }
                if (item.elems && Array.isArray(item.elems)) {
                  count += countToolsRecursively(item.elems, item.name || item.id || sectionName);
                }
              }
            }
            
            return count;
          };
          
          data.forEach((section, index) => {
            const sectionName = section?.name || section?.id || `section-${index}`;
            const sectionCount = countToolsRecursively(section, sectionName);
            totalTools += sectionCount;
            if (sectionCount > 0) {
              console.log(`${cleanUrl}: ${source} - Section "${sectionName}" has ${sectionCount} tools`);
            }
          });
          
          if (totalTools > 0) {
            console.log(`${cleanUrl}: ${source} - got ${totalTools} tools from ${data.length} sections (recursive count)`);
            return totalTools;
          } else {
            // Fallback: count array items as tools
            console.log(`${cleanUrl}: ${source} - no tools in sections, using array length: ${data.length}`);
            return data.length;
          }
        }
      }
      
      // Handle objects
      if (typeof data === 'object') {
        // Check for direct count fields
        if (data.tool_count) {
          console.log(`${cleanUrl}: ${source} - got ${data.tool_count} from tool_count field`);
          return data.tool_count;
        }
        if (data.total) {
          console.log(`${cleanUrl}: ${source} - got ${data.total} from total field`);
          return data.total;
        }
        if (data.count) {
          console.log(`${cleanUrl}: ${source} - got ${data.count} from count field`);
          return data.count;
        }
        
        // Check for tools array
        if (data.tools && Array.isArray(data.tools)) {
          return extractToolCountFromData(cleanUrl, data.tools, source + '.tools');
        }
        
        console.log(`${cleanUrl}: ${source} - unrecognized object structure:`, Object.keys(data));
      }
      
      console.log(`${cleanUrl}: ${source} - could not extract tool count`);
      return 'Unknown';
    }

    // Function to extract genome count from API response data
    function extractGenomeCount(cleanUrl, genomesData) {
      console.log(`${cleanUrl}: Extracting genome count from genomes data`);
      
      if (!genomesData || genomesData.error) {
        console.log(`${cleanUrl}: Genomes data has error or is empty`);
        return 0;
      }
      
      // Handle arrays (most common for genomes API)
      if (Array.isArray(genomesData)) {
        console.log(`${cleanUrl}: Got ${genomesData.length} genomes from genomes API`);
        return genomesData.length;
      }
      
      // Handle objects with genome data
      if (typeof genomesData === 'object') {
        // Check for direct count fields
        if (genomesData.count) {
          console.log(`${cleanUrl}: Got ${genomesData.count} genomes from count field`);
          return genomesData.count;
        }
        
        // Check for genomes array
        if (genomesData.genomes && Array.isArray(genomesData.genomes)) {
          console.log(`${cleanUrl}: Got ${genomesData.genomes.length} genomes from genomes array`);
          return genomesData.genomes.length;
        }
        
        // Check for data array
        if (genomesData.data && Array.isArray(genomesData.data)) {
          console.log(`${cleanUrl}: Got ${genomesData.data.length} genomes from data array`);
          return genomesData.data.length;
        }
        
        console.log(`${cleanUrl}: Unrecognized genomes object structure:`, Object.keys(genomesData));
      }
      
      console.log(`${cleanUrl}: Could not extract genome count`);
      return 0;
    }
    
    // Function to format tools and genomes counts into a multi-line display string
    function formatToolsAndGenomes(toolCount, genomeCount) {
      const hasTools = typeof toolCount === 'number' && toolCount > 0;
      const hasGenomes = typeof genomeCount === 'number' && genomeCount > 0;
      
      if (!hasTools && !hasGenomes) {
        // If both are missing/zero, return the original tool count (could be error message)
        return toolCount;
      }
      
      if (hasTools && hasGenomes) {
        return `${toolCount} tools<br><small style="color: #666; font-size: 0.85em;">${genomeCount} genomes</small>`;
      }
      
      if (hasTools && !hasGenomes) {
        return `${toolCount} tools`;
      }
      
      if (!hasTools && hasGenomes) {
        return `${genomeCount} genomes`;
      }
      
      return toolCount;
    }
    
    async function fetchGalaxyInfo(url) {
      // Check if we're running locally (file:// protocol)
      const isLocalFile = window.location.protocol === 'file:';
      
      console.log(`fetchGalaxyInfo called for: ${url}, isLocalFile: ${isLocalFile}, protocol: ${window.location.protocol}`);
      
      if (isLocalFile) {
        console.log('Returning local mode for:', url);
        return Promise.resolve({ version: 'Local Mode', toolCount: 'Local Mode', configData: {} });
      }
      
      // Clean and validate the URL
      let cleanUrl = url.trim();
      if (!cleanUrl) {
        console.log('No URL provided for server');
        return Promise.resolve({ version: 'No URL', toolCount: 'No URL', configData: {} });
      }
      
      // Remove trailing slash if present
      cleanUrl = cleanUrl.replace(/\/$/, '');
      
      // Ensure URL has protocol
      if (!cleanUrl.startsWith('http://') && !cleanUrl.startsWith('https://')) {
        cleanUrl = 'https://' + cleanUrl;
      }
      
      console.log(`Fetching Galaxy info from: ${cleanUrl}`);
      
      // Use CORS proxy for API calls to bypass CORS restrictions
      const corsProxy = 'https://corsproxy.io/?url=';
      const versionUrl = `${corsProxy}${encodeURIComponent(cleanUrl + '/api/version')}`;
      // Try multiple endpoints to get the most comprehensive tool count
      const toolsUrl = `${corsProxy}${encodeURIComponent(cleanUrl + '/api/tools?all=true&in_panel=false')}`;
      const toolsUrlFallback = `${corsProxy}${encodeURIComponent(cleanUrl + '/api/tools')}`;
      const toolsInstalledUrl = `${corsProxy}${encodeURIComponent(cleanUrl + '/api/tools?installed=true')}`;
      const toolboxUrl = `${corsProxy}${encodeURIComponent(cleanUrl + '/api/toolbox')}`;
      const configUrl = `${corsProxy}${encodeURIComponent(cleanUrl + '/api/configuration')}`;
      const toolshedUrl = `${corsProxy}${encodeURIComponent(cleanUrl + '/api/tool_shed_repositories?installed=true')}`;
      const genomesUrl = `${corsProxy}${encodeURIComponent(cleanUrl + '/api/genomes')}`;
      
      // Add timeout to prevent hanging requests
      const fetchWithTimeout = (url, timeout = 15000) => {
        console.log(`Starting fetch for: ${url} with timeout: ${timeout}ms`);
        return Promise.race([
          fetch(url, { 
            method: 'GET',
            headers: {
              'Accept': 'application/json'
            }
          }),
          new Promise((_, reject) => 
            setTimeout(() => reject(new Error('Timeout')), timeout)
          )
        ]);
      };
      
      // Robust server reachability check that tries to distinguish DNS failures from CORS blocks
      const checkServerStatus = async () => {
        console.log(`Checking server status for: ${cleanUrl}`);
        
        // Try multiple approaches to determine if server is reachable
        const tests = [];
        
        // Test 1: Try a simple image request that might bypass some CORS restrictions
        tests.push(
          new Promise(resolve => {
            const img = new Image();
            const timeout = setTimeout(() => {
              resolve({ test: 'image-favicon', success: false, error: 'timeout' });
            }, 3000);
            
            img.onload = () => {
              clearTimeout(timeout);
              resolve({ test: 'image-favicon', success: true });
            };
            
            img.onerror = (e) => {
              clearTimeout(timeout);
              // Even 404s indicate the server is reachable
              resolve({ test: 'image-favicon', success: false, error: 'load-error-but-reachable' });
            };
            
            img.src = cleanUrl + '/favicon.ico?' + Math.random();
          })
        );
        
        // Test 2: Try a no-cors fetch
        tests.push(
          fetch(cleanUrl + '/robots.txt', { mode: 'no-cors', method: 'HEAD' })
            .then(() => ({ test: 'no-cors-robots', success: true }))
            .catch(error => ({ 
              test: 'no-cors-robots', 
              success: false, 
              error: error.message,
              isDnsError: error.message.includes('ERR_NAME_NOT_RESOLVED') || 
                         error.message.includes('ENOTFOUND') ||
                         error.message.includes('DNS')
            }))
        );
        
        // Test 3: Try another static file
        tests.push(
          fetch(cleanUrl + '/static/favicon.svg', { mode: 'no-cors', method: 'HEAD' })
            .then(() => ({ test: 'no-cors-static', success: true }))
            .catch(error => ({ 
              test: 'no-cors-static', 
              success: false, 
              error: error.message,
              isDnsError: error.message.includes('ERR_NAME_NOT_RESOLVED') || 
                         error.message.includes('ENOTFOUND') ||
                         error.message.includes('DNS')
            }))
        );
        
        const results = await Promise.all(tests);
        console.log(`${cleanUrl}: Reachability test results:`, results);
        
        // If any test succeeded, server is reachable
        if (results.some(r => r.success)) {
          console.log(`${cleanUrl}: Server is reachable (at least one test succeeded)`);
          return { reachable: true, corsBlocked: false };
        }
        
        // If any test shows clear DNS errors, server is offline
        if (results.some(r => r.isDnsError)) {
          console.log(`${cleanUrl}: DNS error detected - server is offline`);
          return { reachable: false, corsBlocked: false };
        }
        
        // All tests failed but no clear DNS errors - likely CORS or online but inaccessible
        console.log(`${cleanUrl}: All tests failed without DNS errors - assuming server is online but CORS-blocked`);
        return { reachable: false, corsBlocked: true };
      };
      
      return Promise.all([
        fetchWithTimeout(versionUrl)
          .then(res => {
            console.log(`Version API response for ${cleanUrl}:`, res.status, res.statusText);
            if (res.ok) {
              return res.json();
            } else {
              // CORS proxy will return specific errors for unreachable servers
              if (res.status === 500 || res.status === 502 || res.status === 503 || res.status === 504 || res.status === 530) {
                throw new Error('SERVER_UNREACHABLE');
              }
              throw new Error(`HTTP_${res.status}`);
            }
          })
          .then(versionJson => {
            console.log(`Version API JSON for ${cleanUrl}:`, versionJson);
            return versionJson;
          })
          .catch(err => {
            console.log(`Version API error for ${cleanUrl}:`, err.message);
            return { error: err.message, type: 'version' };
          }),
        fetchWithTimeout(toolsUrl)
          .then(res => {
            console.log(`Tools API response for ${cleanUrl}:`, res.status, res.statusText);
            if (res.ok) {
              return res.json();
            } else {
              // CORS proxy will return specific errors for unreachable servers
              if (res.status === 500 || res.status === 502 || res.status === 503 || res.status === 504 || res.status === 530) {
                throw new Error('SERVER_UNREACHABLE');
              }
              throw new Error(`HTTP_${res.status}`);
            }
          })
          .then(toolsJson => {
            console.log(`Tools API JSON for ${cleanUrl} (type: ${typeof toolsJson}, isArray: ${Array.isArray(toolsJson)}):`, toolsJson);
            // Log the structure to help debug
            if (Array.isArray(toolsJson) && toolsJson.length > 0) {
              console.log(`${cleanUrl}: First section structure:`, toolsJson[0]);
            }
            return toolsJson;
          })
          .catch(err => {
            console.log(`Tools API error for ${cleanUrl}:`, err.message);
            return { error: err.message, type: 'tools' };
          }),
        fetchWithTimeout(configUrl)
          .then(res => {
            console.log(`Config API response for ${cleanUrl}:`, res.status, res.statusText);
            if (res.ok) {
              return res.json();
            } else {
              throw new Error(`HTTP_${res.status}`);
            }
          })
          .then(configJson => {
            console.log(`Config API JSON for ${cleanUrl}:`, configJson);
            return configJson;
          })
          .catch(err => {
            console.log(`Config API error for ${cleanUrl}:`, err.message);
            return { error: err.message, type: 'config' };
          }),
        fetchWithTimeout(genomesUrl)
          .then(res => {
            console.log(`Genomes API response for ${cleanUrl}:`, res.status, res.statusText);
            if (res.ok) {
              return res.json();
            } else {
              throw new Error(`HTTP_${res.status}`);
            }
          })
          .then(genomesJson => {
            console.log(`Genomes API JSON for ${cleanUrl}:`, genomesJson);
            return genomesJson;
          })
          .catch(err => {
            console.log(`Genomes API error for ${cleanUrl}:`, err.message);
            return { error: err.message, type: 'genomes' };
          }),
        checkServerStatus()
      ]).then(async ([versionData, toolsData, configData, genomesData, serverStatus]) => {
        console.log(`Galaxy info for ${cleanUrl}:`, { versionData, toolsData, configData, genomesData, serverStatus });
        
        // Check for server unreachable errors from the CORS proxy
        const versionError = versionData?.error || '';
        const toolsError = toolsData?.error || '';
        const configError = configData?.error || '';
        const genomesError = genomesData?.error || '';
        
        // Check for DNS/network errors (now indicated by CORS proxy errors)
        const hasServerError = versionError.includes('SERVER_UNREACHABLE') || 
                              toolsError.includes('SERVER_UNREACHABLE') ||
                              versionError.includes('ERR_NAME_NOT_RESOLVED') || 
                              toolsError.includes('ERR_NAME_NOT_RESOLVED') ||
                              versionError.includes('ENOTFOUND') || 
                              toolsError.includes('ENOTFOUND');
        
        const hasTimeoutError = versionError === 'Timeout' || toolsError === 'Timeout';
        
        // Primary check: Look for server unreachable errors from CORS proxy or DNS errors
        if (hasServerError) {
          console.log(`${cleanUrl}: Server unreachable via CORS proxy - server is offline`);
          return { version: 'Offline', toolCount: 'Offline', configData: {} };
        }
        
        // If timeout errors occur and static file tests also indicate unreachable, likely offline
        if (hasTimeoutError && !serverStatus.reachable && !serverStatus.corsBlocked) {
          console.log(`${cleanUrl}: Timeout errors and server tests indicate unreachable - server is offline`);
          return { version: 'Offline', toolCount: 'Offline', configData: {} };
        }
        
        // If we have successful API data from CORS proxy, server is definitely online
        if (versionData && !versionData.error) {
          // Extract version - try different possible fields
          let version = 'Unknown';
          if (versionData.version_major && versionData.version_minor) {
            version = `${versionData.version_major}.${versionData.version_minor}`;
            if (versionData.version_micro) {
              version += `.${versionData.version_micro}`;
            }
          } else if (versionData.version) {
            version = versionData.version;
          } else if (versionData.galaxy_version) {
            version = versionData.galaxy_version;
          }
          
          // Add server start time from config data if available
          let versionWithDate = version;
          if (configData && !configData.error && configData.server_starttime) {
            const startDate = formatServerStartTime(configData.server_starttime);
            if (startDate) {
              versionWithDate = `${version}<br><small style="color: #666; font-size: 0.85em;">Started: ${startDate}</small>`;
            }
          }
          
          // Get comprehensive tool count using multiple endpoints
          const toolCount = await getComprehensiveToolCount(cleanUrl, toolsData, configData, corsProxy);
          
          // Get genome count
          const genomeCount = extractGenomeCount(cleanUrl, genomesData);
          
          // Combine tool and genome counts
          const combinedCount = formatToolsAndGenomes(toolCount, genomeCount);
          
          const result = {
            version: versionWithDate,
            toolCount: combinedCount,
            configData: configData && !configData.error ? configData : {}
          };
          console.log(`${cleanUrl}: Successfully got Galaxy info via CORS proxy:`, result);
          return result;
        }
        
        // If static file tests indicate server is unreachable without CORS issues, it's offline
        if (!serverStatus.reachable && !serverStatus.corsBlocked) {
          console.log(`${cleanUrl}: Server tests indicate unreachable - server is offline`);
          return { version: 'Offline', toolCount: 'Offline', configData: {} };
        }
        
        // If we get here, we have mixed results - server might be online but with API issues
        if (serverStatus.reachable || serverStatus.corsBlocked) {
          console.log(`${cleanUrl}: Server appears reachable but API calls failed - treating as API error`);
          
          // Try to get tool count even with partial data
          let toolCount = 'API Error';
          if (Array.isArray(toolsData)) {
            toolCount = toolsData.length;
          } else if (toolsData?.length) {
            toolCount = toolsData.length;
          } else if (toolsData?.error) {
            toolCount = 'API Error';
          } else {
            toolCount = 'Unknown';
          }
          
          // Try to get genome count even with partial data
          const genomeCount = extractGenomeCount(cleanUrl, genomesData);
          const combinedCount = formatToolsAndGenomes(toolCount, genomeCount);
          
          const result = {
            version: versionData?.version || (versionData?.error ? 'API Error' : 'Unknown'),
            toolCount: combinedCount,
            configData: configData && !configData.error ? configData : {}
          };
          return result;
        }
        
        // Default case: unable to determine conclusively
        console.log(`${cleanUrl}: Unable to determine status conclusively - treating as unknown`);
        return { version: 'Unknown', toolCount: 'Unknown', configData: {} };
      });
    }

    function updateStatus(message, isError = false) {
      const statusDiv = document.getElementById('status');
      statusDiv.textContent = message;
      statusDiv.style.background = isError ? '#ffebee' : '#e3f2fd';
      statusDiv.style.borderColor = isError ? '#f44336' : '#2196f3';
    }

    function renderTable(data) {
      if (!data || data.length === 0) {
        updateStatus('No data found in the spreadsheet or unable to access it.', true);
        return;
      }

      console.log('Rendering table with data:', data);
      updateStatus(`Found ${data.length} server(s) in the spreadsheet. Loading Galaxy API data...`);
      
      // Store data globally for sorting and filtering
      currentData = data;
      filteredData = [...data]; // Initialize filtered data
      
      // Initialize sorting functionality
      initializeTableSorting();
      
      // Initialize search filter
      setupSearchFilter();
      
      // Show initial loading state with status icons
      renderTableRows(currentData);
      updateSummaryStats();
      
      // Fetch Galaxy info for all servers ONCE
      fetchAllGalaxyInfo(data).then(() => {
        // After all API calls are done, render the table again with updated data
        renderTableRows(filteredData.length > 0 ? filteredData : currentData);
        updateStatus(`Loaded ${data.length} server(s). Galaxy API data fetched successfully.`);
        updateSummaryStats();
      });
    }

    async function fetchAllGalaxyInfo(data) {
      let completedCount = 0;
      const totalCount = data.length;
      
      console.log(`Starting fetchAllGalaxyInfo for ${totalCount} servers`);
      
      const updateProgress = () => {
        completedCount++;
        updateStatus(`Loading Galaxy API data... (${completedCount}/${totalCount} completed)`);
        
        // Re-render table to show progressive updates
        renderTableRows(filteredData.length > 0 ? filteredData : currentData);
        updateSummaryStats();
      };
      
      const promises = data.map(async (row, index) => {
        const url = row['URL'] || row['url'] || '';
        console.log(`Processing server ${index + 1}/${totalCount}: ${row['Name']} - ${url}`);
        
        if (url && url.trim()) {
          try {
            const info = await fetchGalaxyInfo(url.trim());
            // Store the API results directly in the data object
            row['Version'] = info.version;
            row['Tool Count'] = info.toolCount;
            row['ConfigData'] = info.configData || {};
            console.log(`Galaxy API completed for ${url.trim()}:`, info);
          } catch (error) {
            console.error(`Error fetching Galaxy info for ${url.trim()}:`, error);
            row['Version'] = 'Error';
            row['Tool Count'] = 'Error';
            row['ConfigData'] = {};
          }
        } else {
          console.log(`No URL provided for server: ${row['Name']}`);
          row['Version'] = 'N/A';
          row['Tool Count'] = 'N/A';
          row['ConfigData'] = {};
        }
        
        console.log(`Final status for ${row['Name']}: Version=${row['Version']}, ToolCount=${row['Tool Count']}`);
        
        // Update progress and re-render after each completion
        updateProgress();
      });

      // Wait for all API calls to complete
      await Promise.all(promises);
      console.log('All Galaxy API calls completed');
      console.log('Final data state:', currentData.map(row => ({ name: row['Name'], version: row['Version'], toolCount: row['Tool Count'] })));
    }

    function renderTableRows(data) {
      const tbody = document.querySelector('#galaxy-table tbody');
      tbody.innerHTML = ''; // Clear existing rows
      
      if (!data || data.length === 0) {
        showNoResults();
        return;
      }
      
      data.forEach((row, index) => {
        const tr = document.createElement('tr');
        
        // Status column with icon and tooltip
        const tdStatus = document.createElement('td');
        const version = row['Version'] || 'Loading...';
        const statusInfo = getStatusIcon(version);
        tdStatus.innerHTML = `<span class="status-icon" style="font-size: 1.2rem;" title="${statusInfo.tooltip}">${statusInfo.icon}</span>`;
        tdStatus.style.textAlign = 'center';
        tdStatus.style.width = '50px';
        
        // Tier column (narrow to match status)
        const tdTier = document.createElement('td');
        const tierValue = row['Tier'] || '';
        let tierIcon = '';
        let tierTooltip = '';
        
        // Display tier icons based on tier value
        if (tierValue === '1') {
          tierIcon = '<i class="fas fa-globe" title="Tier 1 - Global/Major Server" style="color: #4caf50;"></i>';
          tierTooltip = 'Tier 1 - Global/Major Server';
        } else if (tierValue === '2') {
          tierIcon = '<i class="fas fa-university" title="Tier 2 - Institutional Server" style="color: #ff9800;"></i>';
          tierTooltip = 'Tier 2 - Institutional Server';
        } else if (tierValue === '3') {
          tierIcon = '<i class="fas fa-map-marker-alt" title="Tier 3 - Local Server" style="color: #2196f3;"></i>';
          tierTooltip = 'Tier 3 - Local Server';
        } else if (tierValue) {
          // Fallback for other tier values
          tierIcon = tierValue;
          tierTooltip = `Tier ${tierValue}`;
        }
        
        tdTier.innerHTML = tierIcon;
        tdTier.title = tierTooltip;
        tdTier.style.textAlign = 'center';
        tdTier.style.width = '50px';
        
        // Name column with favicon, hyperlink, and URL beneath
        const tdName = document.createElement('td');
        const serverName = row['Name'] || '';
        const url = row['URL'] || row['url'] || '';
        
        let faviconHtml = '';
        let nameContent = '';
        let urlContent = '';
        
        if (url && url.trim()) {
          // Ensure URL has proper protocol for favicon and links
          let cleanUrl = url.trim();
          if (!cleanUrl.startsWith('http://') && !cleanUrl.startsWith('https://')) {
            cleanUrl = 'https://' + cleanUrl;
          }
          faviconHtml = `<img src="${cleanUrl}/favicon.ico" alt="" class="server-favicon" onerror="this.style.display='none';">`;
          
          // Make server name a hyperlink
          nameContent = `<a href="${cleanUrl}" target="_blank" style="color: inherit; text-decoration: none; font-weight: 500;">${serverName}</a>`;
          
          // Add URL beneath the name
          urlContent = `<a href="${cleanUrl}" target="_blank" class="server-url">${url.trim()}</a>`;
          
          tdName.innerHTML = `<div class="server-name-container">${faviconHtml}<div class="server-name-info">${nameContent}${urlContent}</div></div>`;
        } else {
          nameContent = `<span style="font-weight: 500;">${serverName}</span>`;
          urlContent = `<span class="server-url" style="color: #999;">No URL provided</span>`;
          tdName.innerHTML = `<div class="server-name-container">${faviconHtml}<div class="server-name-info">${nameContent}${urlContent}</div></div>`;
        }
        
        // Remove the URL column - it's now part of the Name column
        
        // Region column
        const tdRegion = document.createElement('td');
        tdRegion.textContent = row['Region'] || '';
        
        // Institution column with markdown link parsing and notes beneath
        const tdInstitution = document.createElement('td');
        const institutionText = row['Institution'] || '';
        const notesText = row['Notes'] || '';
        
        let institutionContent = parseMarkdownLinks(institutionText);
        let institutionHtml = '';
        
        if (institutionContent) {
          institutionHtml += `<div>${institutionContent}</div>`;
        }
        
        if (notesText) {
          institutionHtml += `<div class="institution-notes">${notesText}</div>`;
        }
        
        if (institutionHtml) {
          tdInstitution.innerHTML = `<div class="institution-info">${institutionHtml}</div>`;
        }
        
        // Remove the Notes column - it's now part of the Institution column
        
        // Info column (replaced contact with icons)
        const tdContact = document.createElement('td');
        const configData = row['ConfigData'] || {};
        
        let linksHtml = '<div class="contact-icons">';
        
        // Support icon (fa-question-circle)
        if (configData.support_url) {
          linksHtml += `<a href="${configData.support_url}" target="_blank" class="contact-icon" title="Support"><i class="fas fa-question-circle"></i></a>`;
        } else {
          linksHtml += `<span class="contact-icon disabled" title="Support not available"><i class="fas fa-question-circle"></i></span>`;
        }
        
        // Mailing list icon (fa-envelope)
        if (configData.mailing_join_addr) {
          linksHtml += `<a href="mailto:${configData.mailing_join_addr}" class="contact-icon" title="Mailing List"><i class="fas fa-envelope"></i></a>`;
        } else {
          linksHtml += `<span class="contact-icon disabled" title="Mailing list not available"><i class="fas fa-envelope"></i></span>`;
        }
        
        // Citation icon (fa-link)
        if (configData.citation_url) {
          linksHtml += `<a href="${configData.citation_url}" target="_blank" class="contact-icon" title="Cite"><i class="fas fa-link"></i></a>`;
        } else {
          linksHtml += `<span class="contact-icon disabled" title="Citation not available"><i class="fas fa-link"></i></span>`;
        }
        
        // Lock/Unlock icon based on require_login
        if (configData.require_login === true) {
          linksHtml += `<span class="contact-icon" title="Login Required" style="color: #ff9800;"><i class="fas fa-lock"></i></span>`;
        } else if (configData.require_login === false) {
          linksHtml += `<span class="contact-icon" title="No Login Required" style="color: #4caf50;"><i class="fas fa-unlock"></i></span>`;
        }
        
        // Quota icon based on enable_quotas
        if (configData.enable_quotas === true) {
          linksHtml += `<span class="contact-icon" title="Quotas Enabled" style="color: #2196f3;"><i class="fas fa-chart-pie"></i></span>`;
        } else if (configData.enable_quotas === false) {
          linksHtml += `<span class="contact-icon" title="Quotas Disabled" style="color: #999;"><i class="fas fa-chart-pie"></i></span>`;
        }
        
        linksHtml += '</div>';
        tdContact.innerHTML = linksHtml;
        tdContact.style.width = '100px';
        tdContact.style.textAlign = 'center';
        
        // Server column (without status icon since it's now separate)
        const tdVersion = document.createElement('td');
        if (version === 'Loading...') {
          tdVersion.innerHTML = `<span class="loading-indicator"></span> ${version}`;
        } else {
          // Use innerHTML to support the formatted version with start date
          tdVersion.innerHTML = version;
        }
        
        // Resources column (tools and genomes)
        const tdToolCount = document.createElement('td');
        const toolCount = row['Tool Count'] || 'Loading...';
        
        if (toolCount === 'Loading...') {
          tdToolCount.innerHTML = `<span class="loading-indicator"></span> ${toolCount}`;
        } else {
          // Use innerHTML to support multi-line display
          tdToolCount.innerHTML = toolCount;
        }
        
        // Center align info, server, and resources columns
        tdContact.style.textAlign = 'center';
        tdVersion.style.textAlign = 'center';
        tdToolCount.style.textAlign = 'center';
        
        // Apply color coding based on version status
        if (version === 'Offline') {
          tdVersion.style.color = '#f44336';
          tdToolCount.style.color = '#f44336';
        } else if (version === 'CORS Blocked') {
          tdVersion.style.color = '#ff9800';
          tdToolCount.style.color = '#ff9800';
          tdVersion.title = 'Server appears online but API calls blocked by browser CORS policy. Will work when deployed to GitHub Pages.';
          tdToolCount.title = 'Server appears online but API calls blocked by browser CORS policy. Will work when deployed to GitHub Pages.';
        } else if (version === 'Unknown' || version === 'API Error' || version === 'Error') {
          tdVersion.style.color = '#ff9800';
          tdToolCount.style.color = '#ff9800';
        } else if (version === 'Loading...' || version === 'N/A') {
          tdVersion.style.color = '#999';
          tdToolCount.style.color = '#999';
        } else {
          tdVersion.style.color = '#4caf50';
          tdToolCount.style.color = '#4caf50';
        }
        
        // Add loading class for progressive update effect
        if (version === 'Loading...' || toolCount === 'Loading...') {
          tr.classList.add('loading-row');
        }
        
        tr.appendChild(tdStatus);
        tr.appendChild(tdTier);
        tr.appendChild(tdName);
        tr.appendChild(tdRegion);
        tr.appendChild(tdInstitution);
        tr.appendChild(tdContact);
        tr.appendChild(tdVersion);
        tr.appendChild(tdToolCount);
        tbody.appendChild(tr);
      });
    }

    window.addEventListener('DOMContentLoaded', () => {
      loadSpreadsheetData();
    });
  </script>
</body>
</html>

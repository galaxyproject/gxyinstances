<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Galaxy Instance Tracker</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
  <style>
    body {
      font-family: sans-serif;
      padding: 2rem;
      background: #f4f4f4;
    }
    
    .header-section {
      background: #fff;
      padding: 1.5rem;
      margin-bottom: 1rem;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    
    .summary-stats {
      display: flex;
      gap: 1.5rem;
      font-size: 1rem;
    }
    
    .stat-box {
      background: #e3f2fd;
      padding: 0.75rem;
      border-radius: 6px;
      text-align: center;
      min-width: 100px;
    }
    
    .stat-number {
      font-size: 1.2rem;
      font-weight: bold;
      color: #1976d2;
    }
    
    .spreadsheet-link {
      margin: 1rem 0;
      padding: 0.75rem;
      background: #f5f5f5;
      border-radius: 4px;
    }
    
    .search-container {
      margin: 1rem 0;
    }
    
    .search-input {
      width: 100%;
      padding: 0.75rem;
      border: 1px solid #ccc;
      border-radius: 4px;
      font-size: 1rem;
      box-sizing: border-box;
    }
    
    .search-input:focus {
      border-color: #2196f3;
      outline: none;
      box-shadow: 0 0 0 2px rgba(33, 150, 243, 0.2);
    }
    
    table {
      width: 100%;
      border-collapse: collapse;
      background: #fff;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    
    th, td {
      padding: 0.75rem;
      border: 1px solid #ccc;
      text-align: left;
    }
    
    /* Set column widths */
    th:nth-child(1), td:nth-child(1) { /* Status column */
      width: 50px;
      max-width: 50px;
    }
    
    th:nth-child(2), td:nth-child(2) { /* Tier column */
      width: 50px;
      max-width: 50px;
    }
    
    th:nth-child(3), td:nth-child(3) { /* Name column */
      width: 240px;
      max-width: 240px;
    }
    
    th:nth-child(4), td:nth-child(4) { /* Region column */
      width: 100px;
      max-width: 100px;
    }
    
    th:nth-child(6), td:nth-child(6) { /* Info column - narrower with rowspan */
      width: 75px;
      max-width: 75px;
    }
    
    th {
      background: #444;
      color: white;
      cursor: pointer;
      user-select: none;
      position: relative;
    }
    
    /* Center align the status and tier column headers */
    th:nth-child(1), th:nth-child(2) {
      text-align: center;
    }
    
    /* Center align Info, Server, and Resources column headers */
    th:nth-child(6), th:nth-child(7), th:nth-child(8) {
      text-align: center;
    }
    
    /* Server column styling for multi-line content */
    td:nth-child(7) {
      line-height: 1.3;
      vertical-align: top;
    }
    
    /* Resources column styling for multi-line content */
    td:nth-child(8) {
      line-height: 1.3;
      vertical-align: top;
    }
    
    th:hover {
      background: #555;
    }
    
    th.sort-asc::after {
      content: ' ▲';
      position: absolute;
      right: 8px;
    }
    
    th.sort-desc::after {
      content: ' ▼';
      position: absolute;
      right: 8px;
    }
    
    /* Zebra striping for table rows */
    tbody tr:nth-child(even) {
      background-color: #f9f9f9;
    }
    
    tbody tr:hover {
      background-color: #e3f2fd;
    }
    
    .status-icon {
      margin-right: 0.5rem;
      font-size: 1.1rem;
      display: inline-block;
      min-width: 20px;
      text-align: center;
    }
    
    /* Ensure status column is always visible and properly sized */
    .status-column {
      width: 50px !important;
      max-width: 50px !important;
      min-width: 50px !important;
      text-align: center !important;
      vertical-align: middle !important;
    }
    
    /* Progressive loading indicator */
    .loading-indicator {
      display: inline-block;
      width: 12px;
      height: 12px;
      border: 2px solid #f3f3f3;
      border-top: 2px solid #2196f3;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-right: 0.5rem;
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    /* Smooth transitions for progressive loading */
    tbody tr {
      transition: opacity 0.3s ease;
    }
    
    .loading-row {
      opacity: 0.7;
    }
    
    /* Galaxy logo styling in header */
    .header-title {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 1rem;
      margin-bottom: 1rem;
    }
    
    .title-section {
      display: flex;
      align-items: center;
      gap: 1rem;
    }
    
    .galaxy-logo {
      max-width: 150px;
      max-height: 60px;
      height: auto;
      width: auto;
      object-fit: contain;
    }
    
    .header-title h1 {
      margin: 0;
      font-size: 2.5rem;
      color: #333;
    }
    
    /* Server favicon styling */
    .server-favicon {
      width: 16px;
      height: 16px;
      margin-right: 0.5rem;
      vertical-align: middle;
      border-radius: 2px;
    }
    
    .server-name-container {
      display: flex;
      align-items: center;
    }
    
    .server-name-info {
      display: flex;
      flex-direction: column;
      gap: 0.25rem;
    }
    
    .server-url {
      font-size: 0.85em;
      color: #666;
      text-decoration: none;
    }
    
    .server-url:hover {
      color: #2196f3;
      text-decoration: underline;
    }
    
    .institution-info {
      display: flex;
      flex-direction: column;
      gap: 0.1rem;
    }
    
    .institution-notes {
      font-size: 0.85em;
      color: #666;
      font-style: italic;
      margin-top: 0.1rem;
    }
    
    /* Info field styling */
    .contact-container {
      line-height: 1.4;
    }
    
    .contact-name {
      font-weight: 500;
      margin-bottom: 2px;
    }
    
    .contact-email {
      font-size: 0.9em;
      color: #666;
    }
    
    /* Links/Info icons styling */
    .contact-icons {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      grid-template-rows: repeat(2, 1fr);
      gap: 0.4rem;
      justify-items: center;
      align-items: center;
      max-width: 60px;
      margin: 0 auto;
    }
    
    /* Place the 4th, 5th, and 6th icons on the second row, filling all three columns */
    .contact-icons .contact-icon:nth-child(4) {
      grid-column: 1 / 2;
      grid-row: 2;
    }
    
    .contact-icons .contact-icon:nth-child(5) {
      grid-column: 2 / 3;
      grid-row: 2;
    }
    
    .contact-icons .contact-icon:nth-child(6) {
      grid-column: 3 / 4;
      grid-row: 2;
    }
    
    .contact-icon {
      color: #666;
      font-size: 1.1rem;
      text-decoration: none;
      transition: color 0.2s ease;
    }
    
    .contact-icon:hover {
      color: #2196f3;
    }
    
    .contact-icon.disabled {
      color: #ccc;
      cursor: not-allowed;
    }
    
    /* Refresh button styling */
    #refresh-button:hover:not(:disabled) {
      background: #1976d2;
      transform: translateY(-1px);
    }
    
    #refresh-button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }
    
    .no-results {
      text-align: center;
      font-style: italic;
      color: #666;
      padding: 2rem !important;
    }
    
    /* Improved responsive design */
    @media (max-width: 768px) {
      .header-title {
        flex-direction: column;
        text-align: center;
        gap: 1rem;
      }
      
      .title-section {
        flex-direction: column;
        gap: 0.5rem;
      }
      
      .summary-stats {
        flex-direction: column;
        gap: 1rem;
      }
      
      .stat-box {
        min-width: auto;
      }
      
      table {
        font-size: 0.9rem;
      }
      
      th, td {
        padding: 0.5rem;
      }
      
      .header-title {
        flex-direction: column;
        text-align: center;
        gap: 0.5rem;
      }
      
      .galaxy-logo {
        max-width: 120px;
        max-height: 45px;
      }
      
      .header-title h1 {
        font-size: 1.8rem;
      }
    }
  </style>
</head>
<body>
  <div class="header-section">
    <div class="header-title">
      <div class="title-section">
        <img src="https://galaxyproject.org/images/galaxy-logos/galaxy_project_logo_square_no_text_trans.png" alt="Galaxy Project Logo" class="galaxy-logo">
        <h1>Galaxy Instance Tracker</h1>
      </div>
      
      <div id="summary-stats" class="summary-stats" style="display: none;">
        <div class="stat-box">
          <div class="stat-number" id="total-servers">0</div>
          <div>Total Servers</div>
        </div>
        <div class="stat-box">
          <div class="stat-number" id="online-servers">0</div>
          <div>Online Servers</div>
        </div>
        <div class="stat-box">
          <div class="stat-number" id="offline-servers">0</div>
          <div>Offline/Unknown</div>
        </div>
      </div>
    </div>
    
    <div class="search-container">
      <input type="text" id="search-input" class="search-input" placeholder="🔍 Search servers by name, URL, region, or any other field...">
      <div style="margin-top: 0.75rem; display: flex; align-items: center; gap: 1rem; flex-wrap: wrap;">
        <div style="display: flex; align-items: center; gap: 0.5rem;">
          <input type="checkbox" id="hide-offline-checkbox">
          <label for="hide-offline-checkbox" style="font-size: 0.9rem; cursor: pointer;">Hide offline servers</label>
        </div>
        <button id="refresh-button" style="padding: 0.3rem 0.75rem; background: #2196f3; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 0.85rem;">
          <i class="fas fa-sync-alt"></i> Refresh All
        </button>
      </div>
    </div>
  </div>
  <table id="galaxy-table">
    <thead>
      <tr>
        <th><i class="fas fa-signal" title="Status" style="color: green;"></i></th>
        <th><i class="fas fa-star" title="Tier" style="color: gold;"></i></th>
        <th>Name</th>
        <th>Region</th>
        <th>Institution</th>
        <th style="width: 60px;">Info</th>
        <th>Server</th>
        <th title="Available tools and genomes">Resources</th>
      </tr>
    </thead>
    <tbody></tbody>
  </table>

  <div id="status" style="margin-top: 1rem; padding: 0.75rem; background: #e3f2fd; border: 1px solid #2196f3; border-radius: 4px; text-align: center;">
    Loading data from spreadsheet...
  </div>

  <div class="spreadsheet-link" style="margin-top: 1rem; text-align: center; display: flex; justify-content: center; gap: 2rem; flex-wrap: wrap;">
    <div>📊 <a href="https://docs.google.com/spreadsheets/d/1HSpJ7vOxfnYSjfFm1vs528eydh1gVU40rKR6-1TCeCo/edit#gid=0" target="_blank" style="color: inherit; text-decoration: none;">Source Spreadsheet</a></div>
    <div> | </div>
    <div>🔗 <a href="https://github.com/mschatz/gxyservers" target="_blank" style="color: inherit; text-decoration: none;">GitHub Repository</a></div>
    <div> | </div>
    <div>🌌 <a href="https://gxy.io/kui" target="_blank" style="color: inherit; text-decoration: none;">Galaxy KUI</a></div>
  </div>

  <script>
    const sheetId = '1HSpJ7vOxfnYSjfFm1vs528eydh1gVU40rKR6-1TCeCo';
    
    // Using Google Sheets public CSV endpoint - works well with GitHub Pages
    const sheetUrl = `https://docs.google.com/spreadsheets/d/${sheetId}/export?format=csv&gid=0`;

    // Global variables for sorting and filtering
    let currentData = [];
    let filteredData = [];
    let currentSortColumn = null;
    let currentSortDirection = 'asc';
    
    // Cache configuration
    const CACHE_DURATION = 24 * 60 * 60 * 1000; // 24 hours in milliseconds
    const CACHE_KEY = 'galaxyServerCache';
    
    // Cache management functions
    function saveToCache(serverUrl, apiData) {
      try {
        const cache = getCache();
        cache[serverUrl] = {
          data: apiData,
          timestamp: Date.now()
        };
        localStorage.setItem(CACHE_KEY, JSON.stringify(cache));
      } catch (error) {
        console.log('Error saving to cache:', error);
      }
    }
    
    function getFromCache(serverUrl) {
      try {
        const cache = getCache();
        const cached = cache[serverUrl];
        
        if (cached && (Date.now() - cached.timestamp < CACHE_DURATION)) {
          return cached.data;
        }
        
        // Remove expired cache entry
        if (cached) {
          delete cache[serverUrl];
          localStorage.setItem(CACHE_KEY, JSON.stringify(cache));
        }
        
        return null;
      } catch (error) {
        console.log('Error reading from cache:', error);
        return null;
      }
    }
    
    function getCache() {
      try {
        const cache = localStorage.getItem(CACHE_KEY);
        return cache ? JSON.parse(cache) : {};
      } catch (error) {
        return {};
      }
    }
    
    function clearCache() {
      try {
        localStorage.removeItem(CACHE_KEY);
        console.log('Galaxy server cache cleared');
      } catch (error) {
        console.log('Error clearing cache:', error);
      }
    }
    
    function getCacheStats() {
      const cache = getCache();
      const now = Date.now();
      let validEntries = 0;
      let expiredEntries = 0;
      
      Object.values(cache).forEach(entry => {
        if (now - entry.timestamp < CACHE_DURATION) {
          validEntries++;
        } else {
          expiredEntries++;
        }
      });
      
      return { validEntries, expiredEntries, totalEntries: Object.keys(cache).length };
    }
    
    // Function to parse markdown-style links [text](url) and convert to HTML
    function parseMarkdownLinks(text) {
      if (!text || typeof text !== 'string') {
        return text || '';
      }
      
      // Regular expression to match markdown links: [text](url)
      const markdownLinkRegex = /\[([^\]]+)\]\(([^)]+)\)/g;
      
      // Replace all markdown links with HTML anchor tags
      return text.replace(markdownLinkRegex, (match, linkText, url) => {
        // Only add protocol if none is present (preserve existing http:// or https://)
        let cleanUrl = url.trim();
        if (!cleanUrl.startsWith('http://') && !cleanUrl.startsWith('https://')) {
          cleanUrl = 'https://' + cleanUrl;
        }
        
        return `<a href="${cleanUrl}" target="_blank" style="color: #2196f3; text-decoration: none;">${linkText.trim()}</a>`;
      });
    }
    
    // Function to format server start time from configuration data
    function formatServerStartTime(serverStartTime) {
      if (!serverStartTime) return '';
      
      try {
        let date;
        
        // Handle different timestamp formats
        if (typeof serverStartTime === 'string') {
          // Try to parse as ISO string first
          date = new Date(serverStartTime);
          
          // If that fails and it looks like a numeric string, try parsing as number
          if (isNaN(date.getTime()) && /^\d+(\.\d+)?$/.test(serverStartTime)) {
            const numericTime = parseFloat(serverStartTime);
            // If it's a small number, it's likely in seconds (Unix timestamp)
            // If it's a large number, it's likely in milliseconds
            if (numericTime < 1e10) {
              date = new Date(numericTime * 1000); // Convert seconds to milliseconds
            } else {
              date = new Date(numericTime); // Already in milliseconds
            }
          }
        } else if (typeof serverStartTime === 'number') {
          // Handle numeric timestamps
          if (serverStartTime < 1e10) {
            // Likely in seconds (Unix timestamp)
            date = new Date(serverStartTime * 1000);
          } else {
            // Likely in milliseconds
            date = new Date(serverStartTime);
          }
        } else {
          // Try direct conversion
          date = new Date(serverStartTime);
        }
        
        // Check if the date is valid and reasonable (after 1990, before 2050)
        if (isNaN(date.getTime()) || date.getFullYear() < 1990 || date.getFullYear() > 2050) {
          console.log('Invalid or unreasonable server start time:', serverStartTime, 'parsed as:', date);
          return '';
        }
        
        // Format as a readable date
        return date.toLocaleDateString('en-US', {
          year: 'numeric',
          month: 'short',
          day: 'numeric'
        });
      } catch (error) {
        console.log('Error parsing server start time:', serverStartTime, error);
        return '';
      }
    }
    
    function getStatusIcon(version, toolCount) {
      // Handle null, undefined, or empty version
      if (!version || version === '' || version === null || version === undefined) {
        return { icon: '⏳', tooltip: 'Status unknown - loading or no data available' };
      }
      
      // Convert to string and trim for consistent comparison
      const versionStr = String(version).trim();
      const toolCountStr = String(toolCount || '').trim();
      
      // Handle specific status values that indicate the server is completely offline/unreachable
      if (versionStr === 'Offline') {
        return { icon: '🔴', tooltip: 'Server is offline or unreachable' };
      }
      
      // Check if both version and tools indicate offline/unreachable
      if (toolCountStr === 'Offline' && (versionStr === 'Unknown' || versionStr === 'Error' || versionStr === 'API Error' || versionStr === 'Timeout')) {
        return { icon: '🔴', tooltip: 'Server is offline or unreachable' };
      }
      
      // Check if both version and tool count show API errors (completely unreachable)
      if (versionStr === 'API Error' && toolCountStr === 'API Error') {
        return { icon: '🔴', tooltip: 'Server is offline or unreachable (API calls failed)' };
      }
      
      // Check for explicit network/DNS errors that indicate server is completely offline
      if (versionStr.includes('ERR_NAME_NOT_RESOLVED') || versionStr.includes('ENOTFOUND') || 
          versionStr.includes('SERVER_UNREACHABLE') || versionStr === 'DNS Error') {
        return { icon: '🔴', tooltip: 'Server is offline or unreachable (DNS/network error)' };
      }
      
      if (versionStr === 'No URL') {
        return { icon: '⚫', tooltip: 'No URL provided for this server' };
      }
      if (versionStr === 'Local Mode') {
        return { icon: '🏠', tooltip: 'Running in local mode - limited functionality' };
      }
      
      // Handle loading states
      if (versionStr === 'Loading...' || versionStr === 'N/A') {
        return { icon: '⏳', tooltip: 'Status unknown or loading...' };
      }
      
      // Check if server is providing data (tools/genomes) even if version is problematic
      const hasToolData = toolCountStr && 
                         toolCountStr !== 'Loading...' && 
                         toolCountStr !== 'N/A' && 
                         toolCountStr !== 'Offline' && 
                         toolCountStr !== 'Error' && 
                         toolCountStr !== 'API Error' && 
                         toolCountStr !== 'Unknown' &&
                         toolCountStr !== 'No URL' &&
                         toolCountStr !== 'Local Mode' &&
                         (toolCountStr.includes('tools') || toolCountStr.includes('genomes') || /^\d+$/.test(toolCountStr));
      
      // If we can fetch tools/genomes but version is unknown, server is online with issues
      if ((versionStr === 'Unknown' || versionStr === 'API Error' || versionStr === 'Error') && hasToolData) {
        return { icon: '🟡', tooltip: 'Server is online but has API issues (version unknown, but tools/genomes accessible)' };
      }
      
      // CORS blocked but server appears online
      if (versionStr === 'CORS Blocked') {
        return { icon: '🟡', tooltip: 'Server appears online but API calls are blocked by browser CORS policy' };
      }
      
      // Server requires authentication but is online
      if (versionStr.includes('Auth Required') || versionStr.includes('Authentication')) {
        return { icon: '🟡', tooltip: 'Server is online but requires authentication for API access' };
      }
      
      // Server has issues but may be partially accessible (only if no tool data)
      if ((versionStr === 'Unknown' || versionStr === 'API Error' || versionStr === 'Error') && !hasToolData) {
        return { icon: '🟡', tooltip: 'Server status unknown due to API errors' };
      }
      
      // If version contains HTML (like version with start date), check for known patterns
      if (versionStr.includes('<br>') || versionStr.includes('<small>')) {
        // Extract the main version number before any HTML formatting
        const mainVersion = versionStr.split('<br>')[0].split('<small>')[0].trim();
        if (mainVersion && mainVersion !== '' && mainVersion !== 'Unknown' && mainVersion !== 'Error') {
          return { icon: '🟢', tooltip: 'Server is online and responding' };
        } else {
          return { icon: '❓', tooltip: 'Server status uncertain' };
        }
      }
      
      // Default case: if we have a meaningful version string that's not an error, server is online
      if (versionStr && versionStr !== '' && versionStr !== 'Unknown' && versionStr !== 'Error') {
        return { icon: '🟢', tooltip: 'Server is online and responding' };
      }
      
      // Final fallback for any unhandled cases
      return { icon: '⏳', tooltip: 'Status unknown' };
    }
    
    function updateSummaryStats() {
      if (!currentData || currentData.length === 0) return;
      
      const total = currentData.length;
      
      const online = currentData.filter(row => {
        const version = row['Version'] || '';
        const toolCount = row['Tool Count'] || '';
        const versionStr = String(version).trim();
        const toolCountStr = String(toolCount).trim();
        
        // Server is offline only if it's explicitly marked as such or completely unreachable
        if (versionStr === 'Offline' || versionStr === 'No URL' || versionStr === 'Local Mode') {
          return false;
        }
        
        // Also check for network/DNS errors that indicate completely offline
        if (versionStr.includes('ERR_NAME_NOT_RESOLVED') || versionStr.includes('ENOTFOUND') || 
            versionStr.includes('SERVER_UNREACHABLE') || versionStr === 'DNS Error') {
          return false;
        }
        
        // Check if both version and tools indicate offline
        if (toolCountStr === 'Offline' && (versionStr === 'Unknown' || versionStr === 'Error' || versionStr === 'API Error' || versionStr === 'Timeout')) {
          return false;
        }
        
        // Check if both version and tool count show API errors (completely unreachable)
        if (versionStr === 'API Error' && toolCountStr === 'API Error') {
          return false;
        }
        
        // Server is loading or no data yet
        if (versionStr === 'Loading...' || versionStr === 'N/A' || versionStr === '' || !versionStr) {
          return false;
        }
        
        // Check if server is providing data (tools/genomes) even if version is problematic
        const hasToolData = toolCountStr && 
                           toolCountStr !== 'Loading...' && 
                           toolCountStr !== 'N/A' && 
                           toolCountStr !== 'Offline' && 
                           toolCountStr !== 'Error' && 
                           toolCountStr !== 'API Error' && 
                           toolCountStr !== 'Unknown' &&
                           toolCountStr !== 'No URL' &&
                           toolCountStr !== 'Local Mode' &&
                           (toolCountStr.includes('tools') || toolCountStr.includes('genomes') || /^\d+$/.test(toolCountStr));
        
        // If we can fetch tools/genomes OR have a valid version, server is considered online
        const hasValidVersion = versionStr !== 'Unknown' && 
                               versionStr !== 'API Error' && 
                               versionStr !== 'Error' && 
                               versionStr !== 'CORS Blocked';
        
        // Server is online if it has valid version OR can provide tool/genome data
        return hasValidVersion || hasToolData;
      }).length;
      
      const offline = total - online;
      
      document.getElementById('total-servers').textContent = total;
      document.getElementById('online-servers').textContent = online;
      document.getElementById('offline-servers').textContent = offline;
      document.getElementById('summary-stats').style.display = 'flex';
    }
    
    function setupSearchFilter() {
      const searchInput = document.getElementById('search-input');
      const hideOfflineCheckbox = document.getElementById('hide-offline-checkbox');
      const refreshButton = document.getElementById('refresh-button');
      
      const performFilter = () => {
        const searchTerm = searchInput.value.toLowerCase().trim();
        const hideOffline = hideOfflineCheckbox.checked;
        
        let filtered = [...currentData];
        
        // Apply search filter
        if (searchTerm !== '') {
          filtered = filtered.filter(row => {
            return Object.values(row).some(value => 
              value && value.toString().toLowerCase().includes(searchTerm)
            );
          });
        }
        
        // Apply offline filter
        if (hideOffline) {
          filtered = filtered.filter(row => {
            const version = row['Version'] || '';
            return version !== 'Offline' && version !== 'Error' && version !== 'N/A' && version !== 'No URL';
          });
        }
        
        filteredData = filtered;
        
        // Re-apply current sort if any
        if (currentSortColumn) {
          sortFilteredData(currentSortColumn, currentSortDirection);
        } else {
          renderTableRows(filteredData);
        }
        
        // Show "no results" message if needed
        if (filteredData.length === 0 && (searchTerm !== '' || hideOffline)) {
          showNoResults();
        }
      };
      
      const performRefresh = () => {
        // Clear cache and reload data
        clearCache();
        
        // Show refresh indicator
        refreshButton.innerHTML = '<i class="fas fa-sync-alt fa-spin"></i> Refreshing...';
        refreshButton.disabled = true;
        
        // Reset all server data to loading state
        currentData.forEach(row => {
          row['Version'] = 'Loading...';
          row['Tool Count'] = 'Loading...';
          row['ConfigData'] = {};
        });
        
        // Re-render table to show loading state
        renderTableRows(filteredData.length > 0 ? filteredData : currentData);
        updateSummaryStats();
        
        // Fetch fresh data for all servers
        fetchAllGalaxyInfo(currentData, true).then(() => {
          // Restore button state
          refreshButton.innerHTML = '<i class="fas fa-sync-alt"></i> Refresh All';
          refreshButton.disabled = false;
          
          // Re-render table with updated data
          renderTableRows(filteredData.length > 0 ? filteredData : currentData);
          updateStatus(`Refreshed ${currentData.length} server(s). All data updated from Galaxy APIs.`);
          updateSummaryStats();
          
          // Log cache stats
          const cacheStats = getCacheStats();
          console.log(`Cache refreshed. New entries: ${cacheStats.validEntries}`);
        });
      };
      
      searchInput.addEventListener('input', performFilter);
      hideOfflineCheckbox.addEventListener('change', performFilter);
      refreshButton.addEventListener('click', performRefresh);
    }
    
    function showNoResults() {
      const tbody = document.querySelector('#galaxy-table tbody');
      tbody.innerHTML = '<tr><td colspan="8" class="no-results">No servers match your search criteria.</td></tr>';
    }

    function initializeTableSorting() {
      const headers = document.querySelectorAll('#galaxy-table th');
      const columnNames = ['Status', 'Tier', 'Name', 'Region', 'Institution', 'Info', 'Server', 'Resources'];
      
      headers.forEach((header, index) => {
        header.addEventListener('click', () => {
          // Use the predefined column name based on the header index
          const columnName = columnNames[index];
          if (columnName) {
            sortTable(columnName);
          }
        });
      });
    }

    function sortTable(columnName) {
      if (!currentData || currentData.length === 0) return;

      // Determine sort direction
      if (currentSortColumn === columnName) {
        currentSortDirection = currentSortDirection === 'asc' ? 'desc' : 'asc';
      } else {
        currentSortDirection = 'asc';
        currentSortColumn = columnName;
      }

      // Update header indicators
      const headers = document.querySelectorAll('#galaxy-table th');
      const columnNames = ['Status', 'Tier', 'Name', 'Region', 'Institution', 'Info', 'Server', 'Resources'];
      
      headers.forEach((header, index) => {
        header.classList.remove('sort-asc', 'sort-desc');
        if (columnNames[index] === columnName) {
          header.classList.add(currentSortDirection === 'asc' ? 'sort-asc' : 'sort-desc');
        }
      });

      // Sort the filtered data (or all data if no filter)
      const dataToSort = filteredData.length > 0 ? filteredData : currentData;
      sortFilteredData(columnName, currentSortDirection);
    }
    
    function sortFilteredData(columnName, direction) {
      const dataToSort = filteredData.length > 0 ? filteredData : currentData;
      
      const sortedData = [...dataToSort].sort((a, b) => {
        let aVal, bVal;
        
        // Handle special column mappings
        if (columnName === 'Status') {
          // Sort by Version field for status
          aVal = a['Version'] || '';
          bVal = b['Version'] || '';
        } else if (columnName === 'Info') {
          // Sort by contact name or email for info column
          aVal = a['Contact Name'] || a['Contact Email'] || '';
          bVal = b['Contact Name'] || b['Contact Email'] || '';
        } else if (columnName === 'Resources') {
          // Sort by Tool Count field for resources column
          aVal = a['Tool Count'] || '';
          bVal = b['Tool Count'] || '';
        } else if (columnName === 'Server') {
          // Sort by Version field for server column (version numbers)
          aVal = a['Version'] || '';
          bVal = b['Version'] || '';
        } else {
          aVal = a[columnName] || '';
          bVal = b[columnName] || '';
        }

        // Handle version number sorting for Server column
        if (columnName === 'Server') {
          // Extract version numbers from strings that may contain HTML or additional text
          const extractVersion = (versionStr) => {
            if (!versionStr || typeof versionStr !== 'string') return '';
            
            // Remove HTML tags and extra text, extract main version
            let cleanVersion = versionStr.replace(/<[^>]*>/g, '').split('<br>')[0].split('(')[0].trim();
            
            // Handle special status values - these should sort to the end
            const statusValues = ['Loading...', 'Unknown', 'Error', 'API Error', 'Offline', 'No URL', 'Local Mode', 'CORS Blocked', 'Timeout'];
            if (statusValues.includes(cleanVersion)) {
              return direction === 'asc' ? 'zzz_' + cleanVersion : '000_' + cleanVersion;
            }
            
            // For actual version numbers (e.g., "23.1", "24.0.1"), pad with zeros for proper sorting
            const versionMatch = cleanVersion.match(/^(\d+)\.?(\d*)\.?(\d*)/);
            if (versionMatch) {
              const major = parseInt(versionMatch[1]) || 0;
              const minor = parseInt(versionMatch[2]) || 0;
              const patch = parseInt(versionMatch[3]) || 0;
              
              // Create sortable version string with zero-padding
              return `${major.toString().padStart(3, '0')}.${minor.toString().padStart(3, '0')}.${patch.toString().padStart(3, '0')}`;
            }
            
            // For non-version strings, return as-is
            return cleanVersion.toLowerCase();
          };
          
          const aVersion = extractVersion(aVal);
          const bVersion = extractVersion(bVal);
          
          if (direction === 'asc') {
            return aVersion.localeCompare(bVersion);
          } else {
            return bVersion.localeCompare(aVersion);
          }
        }

        // Handle numeric values for Resources and Tier
        if (columnName === 'Resources' || columnName === 'Tier') {
          const aNum = parseInt(aVal);
          const bNum = parseInt(bVal);
          if (!isNaN(aNum) && !isNaN(bNum)) {
            return direction === 'asc' ? aNum - bNum : bNum - aNum;
          }
        }

        // Handle string comparison
        aVal = aVal.toString().toLowerCase();
        bVal = bVal.toString().toLowerCase();

        if (direction === 'asc') {
          return aVal.localeCompare(bVal);
        } else {
          return bVal.localeCompare(aVal);
        }
      });

      // Update filtered data and re-render
      if (filteredData.length > 0) {
        filteredData = sortedData;
      }
      renderTableRows(sortedData);
    }

    function parseCSV(text) {
      const lines = text.split('\n').filter(line => line.trim());
      if (lines.length === 0) return [];
      
      // Handle CSV parsing with proper quote handling
      function parseCSVLine(line) {
        const result = [];
        let current = '';
        let inQuotes = false;
        
        for (let i = 0; i < line.length; i++) {
          const char = line[i];
          const nextChar = line[i + 1];
          
          if (char === '"') {
            if (inQuotes && nextChar === '"') {
              current += '"';
              i++; // Skip next quote
            } else {
              inQuotes = !inQuotes;
            }
          } else if (char === ',' && !inQuotes) {
            result.push(current.trim());
            current = '';
          } else {
            current += char;
          }
        }
        result.push(current.trim());
        return result;
      }
      
      const headers = parseCSVLine(lines[0]);
      const data = [];
      
      for (let i = 1; i < lines.length; i++) {
        const values = parseCSVLine(lines[i]);
        
        // Skip completely empty rows or rows with only empty/whitespace values
        const hasNonEmptyValue = values.some(value => value && value.trim() !== '');
        if (!hasNonEmptyValue) {
          continue;
        }
        
        const row = {};
        headers.forEach((header, index) => {
          row[header] = values[index] || '';
        });
        
        // Stop parsing if tier is "###" - this marks end of data
        if (row['Tier'] === '###') {
          break;
        }
        
        // Skip lines where tier starts with "#" (comment lines) but continue processing
        if (row['Tier'] && row['Tier'].startsWith('#')) {
          continue;
        }
        
        data.push(row);
      }
      
      return data;
    }

    async function loadSpreadsheetData() {
      updateStatus('Loading data from Google Spreadsheet...');
      
      // Check if we're running locally (file:// protocol or localhost)
      const isLocalFile = window.location.protocol === 'file:';
      const isLocalhost = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
      
      if (isLocalFile) {
        updateStatus('Running from local file. For testing, please use a web server (e.g., python3 -m http.server 8000) or deploy to GitHub Pages.', false);
        renderSampleData();
        return;
      }
      
      if (isLocalhost) {
        updateStatus('Loading data... (Note: Some Galaxy API data may be limited when testing locally due to CORS proxy restrictions)');
      }
      
      try {
        updateStatus('Fetching data from Google Spreadsheet...');
        
        const response = await fetch(sheetUrl, {
          method: 'GET',
          mode: 'cors',
          headers: {
            'Accept': 'text/csv'
          }
        });
        
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        updateStatus('Spreadsheet fetched successfully. Parsing CSV data...');
        
        const csvText = await response.text();
        
        const data = parseCSV(csvText);
        
        if (data.length === 0) {
          throw new Error('No data found in spreadsheet');
        }
        
        updateStatus(`CSV data parsed successfully. Found ${data.length} server(s). Preparing table...`);
        
        renderTable(data);
        
      } catch (error) {
        console.error('Error loading spreadsheet:', error);
        
        // Provide helpful error message for GitHub Pages
        let errorMessage = 'Unable to load data from Google Spreadsheet. ';
        
        if (error.message.includes('CORS')) {
          errorMessage += 'This appears to be a CORS issue. ';
        }
        
        errorMessage += 'For GitHub Pages hosting, please ensure: ';
        errorMessage += '1) The Google Spreadsheet is published to the web (File → Share → Publish to web), ';
        errorMessage += '2) Set sharing to "Anyone on the internet with this link can view", ';
        errorMessage += '3) The spreadsheet has the correct column headers (Tier, Name, URL, Region, Institution, Notes).';
        
        updateStatus(errorMessage, true);
        
        // Show sample data for testing
        renderSampleData();
      }
    }

    function renderSampleData() {
      updateStatus('Showing sample data for testing purposes...', false);
      
      const sampleData = [
        {
          'Name': 'US Galaxy Main',
          'URL': 'https://usegalaxy.org',
          'Region': 'USA',
          'Notes': 'Main Galaxy server for the US',
          'Contact Name': 'Galaxy Team',
          'Contact Email': 'outreach@galaxyproject.org',
          'Tier': '1',
          'ConfigData': {
            'support_url': 'https://help.galaxyproject.org',
            'mailing_join_addr': 'galaxy-announce-join@lists.galaxyproject.org',
            'citation_url': 'https://galaxyproject.org/citing-galaxy'
          }
        }
      ];
      
      renderTable(sampleData);
    }
    
    // Function to get comprehensive tool count by trying multiple endpoints
    async function getComprehensiveToolCount(cleanUrl, primaryToolsData, configData, corsProxy = null) {
      // Try the primary tools data first
      let toolCount = extractToolCountFromData(cleanUrl, primaryToolsData, 'primary');
      
      // If we got a reasonable count, return it
      if (typeof toolCount === 'number' && toolCount > 0) {
        return toolCount;
      }
      
      // If no CORS proxy provided or primary data failed, try config data
      if (typeof toolCount !== 'number' || toolCount <= 0) {
        const configCount = extractToolCountFromData(cleanUrl, configData, 'config');
        if (typeof configCount === 'number' && configCount > 0) {
          return configCount;
        }
      }
      
      // If corsProxy is available and count is still low, try additional endpoints
      if (corsProxy && (typeof toolCount !== 'number' || toolCount < 1000)) {
        const additionalEndpoints = [
          { name: 'installed', url: `${corsProxy}${encodeURIComponent(cleanUrl + '/api/tools?installed=true')}` },
          { name: 'toolbox', url: `${corsProxy}${encodeURIComponent(cleanUrl + '/api/toolbox')}` },
          { name: 'toolshed', url: `${corsProxy}${encodeURIComponent(cleanUrl + '/api/tool_shed_repositories?installed=true')}` }
        ];
        
        let bestCount = toolCount;
        
        for (const endpoint of additionalEndpoints) {
          try {
            const response = await fetch(endpoint.url, {
              method: 'GET',
              headers: { 'Accept': 'application/json' },
              timeout: 5000 // Shorter timeout for additional calls
            });
            
            if (response.ok) {
              const data = await response.json();
              const count = extractToolCountFromData(cleanUrl, data, endpoint.name);
              
              if (typeof count === 'number' && count > bestCount) {
                bestCount = count;
                
                // If we get a really good count, use it
                if (count > 5000) {
                  return count;
                }
              }
            }
          } catch (error) {
            // Silent error handling for additional endpoints
          }
        }
        
        toolCount = bestCount;
      }
      
      // Return the best count we found
      return toolCount;
    }
    
    // Function to extract tool count from API response data
    function extractToolCountFromData(cleanUrl, data, source) {
      if (!data || data.error) {
        return 'API Error';
      }
      
      // Handle arrays (most common for tools API)
      if (Array.isArray(data)) {
        if (source === 'toolshed') {
          // Tool shed repositories - count total tools in all repos
          let totalTools = 0;
          data.forEach(repo => {
            if (repo.tool_count) {
              totalTools += repo.tool_count;
            } else if (repo.tools && Array.isArray(repo.tools)) {
              totalTools += repo.tools.length;
            } else {
              totalTools += 1; // Assume 1 tool per repo if not specified
            }
          });
          return totalTools;
        } else {
          // Regular tools API - count tools in sections with recursive support
          let totalTools = 0;
          
          const countToolsRecursively = (item, sectionName = 'unnamed') => {
            let count = 0;
            
            if (Array.isArray(item)) {
              // Array of items - process each
              item.forEach(subItem => {
                count += countToolsRecursively(subItem, sectionName);
              });
            } else if (item && typeof item === 'object') {
              // Check if this is a direct tool (has ID and no nested structure)
              if (item.id && !item.tools && !item.elems) {
                count = 1;
              } else {
                // This is a section - count tools inside
                if (item.tools && Array.isArray(item.tools)) {
                  count += countToolsRecursively(item.tools, item.name || item.id || sectionName);
                }
                if (item.elems && Array.isArray(item.elems)) {
                  count += countToolsRecursively(item.elems, item.name || item.id || sectionName);
                }
              }
            }
            
            return count;
          };
          
          data.forEach((section, index) => {
            const sectionName = section?.name || section?.id || `section-${index}`;
            const sectionCount = countToolsRecursively(section, sectionName);
            totalTools += sectionCount;
          });
          
          if (totalTools > 0) {
            return totalTools;
          } else {
            // Fallback: count array items as tools
            return data.length;
          }
        }
      }
      
      // Handle objects
      if (typeof data === 'object') {
        // Check for direct count fields
        if (data.tool_count) {
          return data.tool_count;
        }
        if (data.total) {
          return data.total;
        }
        if (data.count) {
          return data.count;
        }
        
        // Check for tools array
        if (data.tools && Array.isArray(data.tools)) {
          return extractToolCountFromData(cleanUrl, data.tools, source + '.tools');
        }
      }
      
      return 'Unknown';
    }

    // Function to extract genome count from API response data
    function extractGenomeCount(cleanUrl, genomesData) {
      if (!genomesData || genomesData.error) {
        return 0;
      }
      
      // Handle arrays (most common for genomes API)
      if (Array.isArray(genomesData)) {
        return genomesData.length;
      }
      
      // Handle objects with genome data
      if (typeof genomesData === 'object') {
        // Check for direct count fields
        if (genomesData.count) {
          return genomesData.count;
        }
        
        // Check for genomes array
        if (genomesData.genomes && Array.isArray(genomesData.genomes)) {
          return genomesData.genomes.length;
        }
        
        // Check for data array
        if (genomesData.data && Array.isArray(genomesData.data)) {
          return genomesData.data.length;
        }
      }
      
      return 0;
    }
    
    // Function to format tools and genomes counts into a multi-line display string
    function formatToolsAndGenomes(toolCount, genomeCount) {
      const hasTools = typeof toolCount === 'number' && toolCount > 0;
      const hasGenomes = typeof genomeCount === 'number' && genomeCount > 0;
      
      if (!hasTools && !hasGenomes) {
        // If both are missing/zero, return the original tool count (could be error message)
        return toolCount;
      }
      
      if (hasTools && hasGenomes) {
        return `<span style="color: #4caf50; font-weight: 500;">${toolCount} tools</span><br><small style="color: #2196f3; font-size: 0.85em; font-weight: 500;">${genomeCount} genomes</small>`;
      }
      
      if (hasTools && !hasGenomes) {
        return `<span style="color: #4caf50; font-weight: 500;">${toolCount} tools</span>`;
      }
      
      if (!hasTools && hasGenomes) {
        return `<span style="color: #2196f3; font-weight: 500;">${genomeCount} genomes</span>`;
      }
      
      return toolCount;
    }
    
    async function fetchGalaxyInfo(url, forceRefresh = false) {
      // Check if we're running locally (file:// protocol)
      const isLocalFile = window.location.protocol === 'file';
      
      if (isLocalFile) {
        return Promise.resolve({ 
          version: 'Local Mode', 
          toolCount: 'Local Mode', 
          configData: {},
          hasProxyIssues: false,
          proxiesAttempted: 0
        });
      }
      
      // Clean and validate the URL
      let cleanUrl = url.trim();
      if (!cleanUrl) {
        return Promise.resolve({ 
          version: 'No URL', 
          toolCount: 'No URL', 
          configData: {},
          hasProxyIssues: false,
          proxiesAttempted: 0
        });
      }
      
      // Remove trailing slash if present
      cleanUrl = cleanUrl.replace(/\/$/, '');
      
      // Only add protocol if none is present (preserve existing http:// or https://)
      if (!cleanUrl.startsWith('http://') && !cleanUrl.startsWith('https://')) {
        cleanUrl = 'https://' + cleanUrl;
      }
      
      // Check cache first (unless forced refresh)
      if (!forceRefresh) {
        const cachedData = getFromCache(cleanUrl);
        if (cachedData) {
          console.log(`${cleanUrl}: Using cached data`);
          return cachedData;
        }
      }
      
      // Multiple CORS proxy options for better reliability
      const corsProxies = [
        'https://corsproxy.io/?url=',
        'https://api.codetabs.com/v1/proxy?quest=',
        'https://cors.bridged.cc/',
        'https://api.allorigins.win/raw?url='
      ];
      
      // Enhanced fetch with timeout and robust multi-proxy retry logic
      const fetchWithTimeout = async (apiEndpoint, timeout = 15000, maxRetries = 2) => {
        const originalUrl = `${cleanUrl}${apiEndpoint}`;
        
        let lastError;
        let proxiesAttempted = 0;
        
        // Try each proxy with retries
        for (let proxyIndex = 0; proxyIndex < corsProxies.length; proxyIndex++) {
          const corsProxy = corsProxies[proxyIndex];
          const url = `${corsProxy}${encodeURIComponent(originalUrl)}`;
          proxiesAttempted++;
          
          // Update status to show proxy retry progress for user feedback
          if (proxyIndex > 0) {
            updateStatus(`Loading Galaxy API data... (Trying backup proxy ${proxyIndex + 1}/${corsProxies.length} for ${cleanUrl.replace('https://', '').replace('http://', '')})`, false);
          }
          
          for (let attempt = 0; attempt <= maxRetries; attempt++) {
            try {
              const response = await Promise.race([
                fetch(url, { 
                  method: 'GET',
                  headers: {
                    'Accept': 'application/json',
                    'User-Agent': 'Galaxy-Server-Tracker/1.0'
                  }
                }),
                new Promise((_, reject) => 
                  setTimeout(() => reject(new Error('Timeout')), timeout)
                )
              ]);
              
              // Success!
              if (response.ok) {
                return response;
              }
              
              // Handle authentication required (indicates server is online but needs auth)
              if (response.status === 401 || response.status === 403) {
                // Check if this is a Galaxy API authentication error
                try {
                  const errorData = await response.clone().json();
                  if (errorData.err_msg && errorData.err_msg.toLowerCase().includes('authentication')) {
                    // Server is online but requires auth - return a special indicator
                    return { 
                      status: 'auth_required', 
                      data: errorData,
                      ok: true // Treat as success since server is responding
                    };
                  }
                } catch (e) {
                  // Not JSON, continue with regular error handling
                }
                
                lastError = new Error('AUTH_REQUIRED');
                break; // Try next proxy
              }
              
              // Handle specific proxy/rate limit errors
              if (response.status === 403) {
                lastError = new Error('PROXY_BLOCKED');
                break; // Try next proxy immediately
              }
              
              if (response.status === 429) {
                lastError = new Error('RATE_LIMITED');
                
                if (attempt < maxRetries) {
                  // Wait before retry with exponential backoff
                  const delay = Math.min(2000 * Math.pow(2, attempt), 8000);
                  updateStatus(`Loading Galaxy API data... (Rate limited, waiting ${Math.round(delay/1000)}s before retry for ${cleanUrl.replace('https://', '').replace('http://', '')})`, false);
                  await new Promise(resolve => setTimeout(resolve, delay));
                  continue;
                } else {
                  break; // Try next proxy
                }
              }
              
              // Server errors that might indicate the target server is down
              if (response.status >= 500) {
                lastError = new Error('SERVER_ERROR');
                
                if (attempt < maxRetries) {
                  await new Promise(resolve => setTimeout(resolve, 1000 * (attempt + 1)));
                  continue;
                } else {
                  break; // Try next proxy
                }
              }
              
              // Other HTTP errors
              lastError = new Error(`HTTP_${response.status}`);
              break; // Try next proxy
              
            } catch (error) {
              lastError = error;
              
              // Retry on timeout or network errors
              if (attempt < maxRetries && (
                error.message === 'Timeout' || 
                error.message.includes('NetworkError') ||
                error.message.includes('Failed to fetch')
              )) {
                const delay = 1000 * (attempt + 1);
                await new Promise(resolve => setTimeout(resolve, delay));
                continue;
              } else {
                break; // Try next proxy
              }
            }
          }
        }
        
        // Add metadata about proxy failures for user feedback
        const error = lastError || new Error('All proxies failed');
        error.proxiesAttempted = proxiesAttempted;
        error.endpoint = apiEndpoint;
        throw error;
      };
      
      // Robust server reachability check that tries to distinguish DNS failures from CORS blocks
      const checkServerStatus = async () => {
        // Try multiple approaches to determine if server is reachable
        const tests = [];
        
        // Test 1: Try a simple image request that might bypass some CORS restrictions
        tests.push(
          new Promise(resolve => {
            const img = new Image();
            const timeout = setTimeout(() => {
              resolve({ test: 'image-favicon', success: false, error: 'timeout' });
            }, 3000);
            
            img.onload = () => {
              clearTimeout(timeout);
              resolve({ test: 'image-favicon', success: true });
            };
            
            img.onerror = (e) => {
              clearTimeout(timeout);
              // Even 404s indicate the server is reachable
              resolve({ test: 'image-favicon', success: false, error: 'load-error-but-reachable' });
            };
            
            img.src = cleanUrl + '/favicon.ico?' + Math.random();
          })
        );
        
        // Test 2: Try a no-cors fetch
        tests.push(
          fetch(cleanUrl + '/robots.txt', { mode: 'no-cors', method: 'HEAD' })
            .then(() => ({ test: 'no-cors-robots', success: true }))
            .catch(error => ({ 
              test: 'no-cors-robots', 
              success: false, 
              error: error.message,
              isDnsError: error.message.includes('ERR_NAME_NOT_RESOLVED') || 
                         error.message.includes('ENOTFOUND') ||
                         error.message.includes('DNS')
            }))
        );
        
        // Test 3: Try another static file
        tests.push(
          fetch(cleanUrl + '/static/favicon.svg', { mode: 'no-cors', method: 'HEAD' })
            .then(() => ({ test: 'no-cors-static', success: true }))
            .catch(error => ({ 
              test: 'no-cors-static', 
              success: false, 
              error: error.message,
              isDnsError: error.message.includes('ERR_NAME_NOT_RESOLVED') || 
                         error.message.includes('ENOTFOUND') ||
                         error.message.includes('DNS')
            }))
        );
        
        const results = await Promise.all(tests);
        
        // If any test succeeded, server is reachable
        if (results.some(r => r.success)) {
          return { reachable: true, corsBlocked: false };
        }
        
        // If any test shows clear DNS errors, server is offline
        if (results.some(r => r.isDnsError)) {
          return { reachable: false, corsBlocked: false };
        }
        
        // All tests failed but no clear DNS errors - likely CORS or online but inaccessible
        return { reachable: false, corsBlocked: true };
      };
      
      return Promise.all([
        fetchWithTimeout('/api/version')
          .then(res => {
            if (res.ok) {
              return res.json();
            } else {
              // CORS proxy will return specific errors for unreachable servers
              if (res.status === 500 || res.status === 502 || res.status === 503 || res.status === 504 || res.status === 530) {
                throw new Error('SERVER_UNREACHABLE');
              }
              throw new Error(`HTTP_${res.status}`);
            }
          })
          .then(versionJson => {
            return versionJson;
          })
          .catch(err => {
            // Try fallback endpoints for older Galaxy servers
            const fallbackEndpoints = [
              '/api', // Some servers expose version info at the base API endpoint
              '/api/whoami', // User info might contain version
              '/history/current_history_json', // Very old Galaxy endpoint
              '/' // Some servers put version info in the main page HTML
            ];
            
            // Try the fallback endpoints sequentially
            const tryFallbacks = async () => {
              for (const endpoint of fallbackEndpoints) {
                try {
                  const response = await fetchWithTimeout(endpoint);
                  if (response.ok) {
                    const contentType = response.headers.get('content-type') || '';
                    
                    if (contentType.includes('application/json')) {
                      const data = await response.json();
                      
                      // Check if we can extract version from this endpoint
                      if (data && (data.version || data.galaxy_version || data.version_major)) {
                        return data;
                      }
                    } else if (endpoint === '/' && contentType.includes('text/html')) {
                      // For the main page, try to extract Galaxy info from HTML
                      const html = await response.text();
                      
                      // Check if this is a Galaxy server
                      if (html.includes('Galaxy') || html.includes('galaxy')) {
                        // Try to extract version from HTML comments or meta tags
                        const versionMatch = html.match(/Galaxy\s+(?:version\s+)?v?(\d+\.\d+(?:\.\d+)?)/i) ||
                                           html.match(/version["\s]*[:=]["\s]*v?(\d+\.\d+(?:\.\d+)?)/i) ||
                                           html.match(/galaxy["\s]*[:=]["\s]*v?(\d+\.\d+(?:\.\d+)?)/i);
                        
                        if (versionMatch) {
                          return { version: versionMatch[1], detectedFrom: 'html' };
                        } else {
                          // We know it's Galaxy but don't have version
                          return { version: 'Galaxy (Legacy)', detectedFrom: 'html' };
                        }
                      }
                    }
                  }
                } catch (fallbackError) {
                  // Continue to next fallback
                  continue;
                }
              }
              
              // If all fallbacks failed, return the original error
              throw err;
            };
            
            return tryFallbacks().catch(() => {
              // Track proxy issues for user feedback
              const hasProxyIssues = err.proxiesAttempted > 1 || err.message.includes('PROXY_BLOCKED') || err.message.includes('RATE_LIMITED');
              return { 
                error: err.message, 
                type: 'version',
                proxiesAttempted: err.proxiesAttempted,
                hasProxyIssues: hasProxyIssues,
                authRequired: err.message.includes('AUTH_REQUIRED')
              };
            });
          }),
        fetchWithTimeout('/api/tools?all=true&in_panel=false')
          .then(res => {
            if (res.ok) {
              return res.json();
            } else {
              // CORS proxy will return specific errors for unreachable servers
              if (res.status === 500 || res.status === 502 || res.status === 503 || res.status === 504 || res.status === 530) {
                throw new Error('SERVER_UNREACHABLE');
              }
              throw new Error(`HTTP_${res.status}`);
            }
          })
          .then(toolsJson => {
            return toolsJson;
          })
          .catch(err => {
            // Try fallback API endpoints if main one fails
            const toolsFallbacks = [
              '/api/tools', // Basic tools endpoint
              '/api/tools?in_panel=true', // Tools in panel
              '/toolbox', // Very old Galaxy toolbox endpoint
              '/api/tool_shed_repositories' // Tool shed repos as fallback
            ];
            
            const tryToolsFallbacks = async () => {
              for (const endpoint of toolsFallbacks) {
                try {
                  const response = await fetchWithTimeout(endpoint);
                  if (response.ok) {
                    const data = await response.json();
                    
                    // Check if we got valid tools data
                    if (Array.isArray(data) || (data && data.tools)) {
                      return data;
                    }
                  }
                } catch (fallbackError) {
                  // Continue to next fallback
                  continue;
                }
              }
              
              // If all fallbacks failed, throw the original error
              throw err;
            };
            
            return tryToolsFallbacks().catch(fallbackErr => {
                const hasProxyIssues = err.proxiesAttempted > 1 || fallbackErr.proxiesAttempted > 1 || 
                                      err.message.includes('PROXY_BLOCKED') || err.message.includes('RATE_LIMITED') ||
                                      fallbackErr.message.includes('PROXY_BLOCKED') || fallbackErr.message.includes('RATE_LIMITED');
                return { 
                  error: err.message, 
                  type: 'tools',
                  proxiesAttempted: Math.max(err.proxiesAttempted || 0, fallbackErr.proxiesAttempted || 0),
                  hasProxyIssues: hasProxyIssues,
                  authRequired: err.message.includes('AUTH_REQUIRED') || fallbackErr.message.includes('AUTH_REQUIRED')
                };
              });
          }),
        fetchWithTimeout('/api/configuration')
          .then(res => {
            if (res.ok) {
              return res.json();
            } else {
              throw new Error(`HTTP_${res.status}`);
            }
          })
          .then(configJson => {
            return configJson;
          })
          .catch(err => {
            const hasProxyIssues = err.proxiesAttempted > 1 || err.message.includes('PROXY_BLOCKED') || err.message.includes('RATE_LIMITED');
            return { 
              error: err.message, 
              type: 'config',
              proxiesAttempted: err.proxiesAttempted,
              hasProxyIssues: hasProxyIssues
            };
          }),
        fetchWithTimeout('/api/genomes')
          .then(res => {
            if (res.ok) {
              return res.json();
            } else {
              throw new Error(`HTTP_${res.status}`);
            }
          })
          .then(genomesJson => {
            return genomesJson;
          })
          .catch(err => {
            const hasProxyIssues = err.proxiesAttempted > 1 || err.message.includes('PROXY_BLOCKED') || err.message.includes('RATE_LIMITED');
            return { 
              error: err.message, 
              type: 'genomes',
              proxiesAttempted: err.proxiesAttempted,
              hasProxyIssues: hasProxyIssues
            };
          }),
        checkServerStatus()
      ]).then(async ([versionData, toolsData, configData, genomesData, serverStatus]) => {
        // Track proxy issues for user feedback and table display
        const hasProxyIssues = [versionData, toolsData, configData, genomesData]
          .some(data => data?.hasProxyIssues || (data?.proxiesAttempted && data.proxiesAttempted > 1));
        
        const totalProxiesAttempted = Math.max(
          versionData?.proxiesAttempted || 0,
          toolsData?.proxiesAttempted || 0,
          configData?.proxiesAttempted || 0,
          genomesData?.proxiesAttempted || 0
        );
        
        // Check for server unreachable errors from the CORS proxy
        const versionError = versionData?.error || '';
        const toolsError = toolsData?.error || '';
        const configError = configData?.error || '';
        const genomesError = genomesData?.error || '';
        
        // Check for DNS/network errors (now indicated by CORS proxy errors)
        const hasServerError = versionError.includes('SERVER_UNREACHABLE') || 
                              toolsError.includes('SERVER_UNREACHABLE') ||
                              versionError.includes('ERR_NAME_NOT_RESOLVED') || 
                              toolsError.includes('ERR_NAME_NOT_RESOLVED') ||
                              versionError.includes('ENOTFOUND') || 
                              toolsError.includes('ENOTFOUND');
        
        const hasTimeoutError = versionError === 'Timeout' || toolsError === 'Timeout';
        
        // Check for authentication required errors (server is online but requires auth)
        const hasAuthRequired = versionData?.authRequired || toolsData?.authRequired || 
                               versionError.includes('AUTH_REQUIRED') || toolsError.includes('AUTH_REQUIRED');
        
        let result;
        
        // Authentication required - server is online but needs auth for API access
        if (hasAuthRequired) {
          result = {
            version: 'Galaxy (Auth Required)',
            toolCount: 'Requires Authentication',
            configData: {},
            hasProxyIssues: hasProxyIssues,
            proxiesAttempted: totalProxiesAttempted
          };
        }
        // Primary check: Look for server unreachable errors from CORS proxy or DNS errors
        else if (hasServerError) {
          result = { 
            version: 'Offline', 
            toolCount: 'Offline', 
            configData: {},
            hasProxyIssues: false,
            proxiesAttempted: totalProxiesAttempted
          };
        }
        // If timeout errors occur and static file tests also indicate unreachable, likely offline
        else if (hasTimeoutError && !serverStatus.reachable && !serverStatus.corsBlocked) {
          result = { 
            version: 'Offline', 
            toolCount: 'Offline', 
            configData: {},
            hasProxyIssues: false,
            proxiesAttempted: totalProxiesAttempted
          };
        }
        // If we have successful API data from CORS proxy, server is definitely online
        else if (versionData && !versionData.error) {
          // Extract version - try different possible fields and formats
          let version = 'Unknown';
          
          // Handle version_major as a complete version string (like TreeGenes "20.01")
          if (versionData.version_major) {
            version = versionData.version_major;
            // If version_minor also exists as a separate field, append it
            if (versionData.version_minor && typeof versionData.version_minor === 'number') {
              version += `.${versionData.version_minor}`;
            }
            // If version_micro also exists, append it
            if (versionData.version_micro) {
              version += `.${versionData.version_micro}`;
            }
          } 
          // Standard modern Galaxy API version fields (both major and minor as numbers)
          else if (versionData.version_major && versionData.version_minor) {
            version = `${versionData.version_major}.${versionData.version_minor}`;
            if (versionData.version_micro) {
              version += `.${versionData.version_micro}`;
            }
          } 
          // Direct version field
          else if (versionData.version) {
            version = versionData.version;
          } 
          // Galaxy-specific version field
          else if (versionData.galaxy_version) {
            version = versionData.galaxy_version;
          }
          // Check for version in nested data structures
          else if (versionData.data && versionData.data.version) {
            version = versionData.data.version;
          }
          // Check for user info with version (from /api/whoami fallback)
          else if (versionData.user && versionData.user.version) {
            version = versionData.user.version;
          }
          // Check for version info in configuration-like responses
          else if (versionData.config && versionData.config.version) {
            version = versionData.config.version;
          }
          // Handle cases where version might be in a different structure
          else if (typeof versionData === 'object') {
            // Look for any field that might contain version info
            const versionFields = ['galaxy_version', 'server_version', 'application_version', 'build_version'];
            for (const field of versionFields) {
              if (versionData[field]) {
                version = versionData[field];
                break;
              }
            }
          }
          
          // If we still don't have a version but the response indicates a Galaxy server
          if (version === 'Unknown' && versionData && typeof versionData === 'object') {
            // Check if response indicates this is a Galaxy server
            const hasGalaxyIndicators = JSON.stringify(versionData).toLowerCase().includes('galaxy') ||
                                       versionData.brand === 'Galaxy' ||
                                       versionData.name === 'Galaxy' ||
                                       versionData.application === 'Galaxy';
            
            if (hasGalaxyIndicators) {
              version = 'Galaxy (Legacy)';
            }
          }
          
          // Add server start time from config data if available
          let versionWithDate = version;
          if (configData && !configData.error && (configData.server_starttime || configData.server_startttime)) {
            const startTime = configData.server_starttime || configData.server_startttime;
            console.log(`[${cleanUrl}] Raw server start time:`, startTime, `(type: ${typeof startTime})`);
            const startDate = formatServerStartTime(startTime);
            console.log(`[${cleanUrl}] Formatted server start time:`, startDate);
            if (startDate) {
              versionWithDate = `${version}<br><small style="color: #666; font-size: 0.85em;">Started: ${startDate}</small>`;
            }
          }
          
          // Get comprehensive tool count using multiple endpoints
          const corsProxy = corsProxies[0]; // Use the first proxy for additional calls
          const toolCount = await getComprehensiveToolCount(cleanUrl, toolsData, configData, corsProxy);
          
          // Get genome count
          const genomeCount = extractGenomeCount(cleanUrl, genomesData);
          
          // Combine tool and genome counts
          const combinedCount = formatToolsAndGenomes(toolCount, genomeCount);
          
          result = {
            version: versionWithDate,
            toolCount: combinedCount,
            configData: configData && !configData.error ? configData : {},
            hasProxyIssues: hasProxyIssues,
            proxiesAttempted: totalProxiesAttempted
          };
        }
        // Fallback for older Galaxy servers: if /api/version failed but we have config data, try to extract version from config
        else if (versionData && versionData.error && configData && !configData.error) {
          let version = 'Unknown';
          
          // Try to extract version from config data (older Galaxy servers)
          // Handle version_major as a complete version string (like TreeGenes)
          if (configData.version_major) {
            version = configData.version_major;
            // If version_minor also exists as a separate field, append it
            if (configData.version_minor && typeof configData.version_minor === 'number') {
              version += `.${configData.version_minor}`;
            }
            // If version_micro also exists, append it
            if (configData.version_micro) {
              version += `.${configData.version_micro}`;
            }
          }
          // Standard format with both major and minor as numbers
          else if (configData.version_major && configData.version_minor) {
            version = `${configData.version_major}.${configData.version_minor}`;
            if (configData.version_micro) {
              version += `.${configData.version_micro}`;
            }
          } else if (configData.version) {
            version = configData.version;
          } else if (configData.galaxy_version) {
            version = configData.galaxy_version;
          }
          
          // Add server start time from config data if available
          let versionWithDate = version;
          if (configData.server_starttime || configData.server_startttime) {
            const startTime = configData.server_starttime || configData.server_startttime;
            console.log(`[Fallback - ${cleanUrl}] Raw server start time:`, startTime, `(type: ${typeof startTime})`);
            const startDate = formatServerStartTime(startTime);
            console.log(`[Fallback - ${cleanUrl}] Formatted server start time:`, startDate);
            if (startDate) {
              versionWithDate = `${version}<br><small style="color: #666; font-size: 0.85em;">Started: ${startDate}</small>`;
            }
          }
          
          // Get comprehensive tool count using multiple endpoints
          const corsProxy = corsProxies[0]; // Use the first proxy for additional calls
          const toolCount = await getComprehensiveToolCount(cleanUrl, toolsData, configData, corsProxy);
          
          // Get genome count
          const genomeCount = extractGenomeCount(cleanUrl, genomesData);
          
          // Combine tool and genome counts
          const combinedCount = formatToolsAndGenomes(toolCount, genomeCount);
          
          result = {
            version: versionWithDate,
            toolCount: combinedCount,
            configData: configData,
            hasProxyIssues: hasProxyIssues,
            proxiesAttempted: totalProxiesAttempted
          };
        }
        // If static file tests indicate server is unreachable without CORS issues, it's offline
        else if (!serverStatus.reachable && !serverStatus.corsBlocked) {
          result = { version: 'Offline', toolCount: 'Offline', configData: {} };
        }
        // If we get here, we have mixed results - server might be online but with API issues
        else if (serverStatus.reachable || serverStatus.corsBlocked) {
          // Try to get tool count even with partial data
          let toolCount = 'API Error';
          if (Array.isArray(toolsData)) {
            toolCount = extractToolCountFromData(cleanUrl, toolsData, 'tools');
          } else if (toolsData?.length) {
            toolCount = toolsData.length;
          } else if (toolsData?.error) {
            toolCount = 'API Error';
          } else {
            toolCount = 'Unknown';
          }
          
          // Try to get genome count even with partial data
          const genomeCount = extractGenomeCount(cleanUrl, genomesData);
          const combinedCount = formatToolsAndGenomes(toolCount, genomeCount);
          
          result = {
            version: versionData?.version || (versionData?.error ? 'API Error' : 'Unknown'),
            toolCount: combinedCount,
            configData: configData && !configData.error ? configData : {},
            hasProxyIssues: hasProxyIssues,
            proxiesAttempted: totalProxiesAttempted
          };
        }
        // Default case: unable to determine conclusively
        else {
          result = { 
            version: 'Unknown', 
            toolCount: 'Unknown', 
            configData: {},
            hasProxyIssues: hasProxyIssues,
            proxiesAttempted: totalProxiesAttempted
          };
        }
        
        // Save successful results to cache (don't cache errors or offline status)
        if (result.version !== 'Offline' && result.version !== 'Error' && result.version !== 'Unknown') {
          saveToCache(cleanUrl, result);
        }
        
        // Validate that we always return a valid version string
        if (!result.version || result.version === '' || result.version === null || result.version === undefined) {
          console.warn(`${cleanUrl}: fetchGalaxyInfo returned empty version, defaulting to 'Unknown'`);
          result.version = 'Unknown';
        }
        
        // Ensure toolCount is also set
        if (!result.toolCount || result.toolCount === '' || result.toolCount === null || result.toolCount === undefined) {
          result.toolCount = 'Unknown';
        }
        
        return result;
      });
    }

    function updateStatus(message, isError = false) {
      const statusDiv = document.getElementById('status');
      statusDiv.textContent = message;
      statusDiv.style.background = isError ? '#ffebee' : '#e3f2fd';
      statusDiv.style.borderColor = isError ? '#f44336' : '#2196f3';
    }

    function renderTable(data) {
      if (!data || data.length === 0) {
        updateStatus('No data found in the spreadsheet or unable to access it.', true);
        return;
      }

      updateStatus(`Found ${data.length} server(s) in the spreadsheet. Loading Galaxy API data...`);
      
      // Store data globally for sorting and filtering
      currentData = data;
      filteredData = [...data]; // Initialize filtered data
      
      // Initialize sorting functionality
      initializeTableSorting();
      
      // Initialize search filter
      setupSearchFilter();
      
      // Show initial loading state with status icons
      renderTableRows(currentData);
      updateSummaryStats();
      
      // Fetch Galaxy info for all servers ONCE
      fetchAllGalaxyInfo(data, false).then(() => {
        // After all API calls are done, render the table again with updated data
        renderTableRows(filteredData.length > 0 ? filteredData : currentData);
        updateStatus(`Loaded ${data.length} server(s). Galaxy API data fetched successfully.`);
        updateSummaryStats();
      });
    }

    async function fetchAllGalaxyInfo(data, forceRefresh = false) {
      let completedCount = 0;
      const totalCount = data.length;
      
      // Log cache stats at start
      if (!forceRefresh) {
        const cacheStats = getCacheStats();
        console.log(`Starting Galaxy API fetch. Cache status: ${cacheStats.validEntries} valid, ${cacheStats.expiredEntries} expired entries`);
      }
      
      const updateProgress = () => {
        completedCount++;
        updateStatus(`Loading Galaxy API data... (${completedCount}/${totalCount} completed)`);
        
        // Re-render table to show progressive updates
        renderTableRows(filteredData.length > 0 ? filteredData : currentData);
        updateSummaryStats();
      };
      
      const promises = data.map(async (row, index) => {
        const url = row['URL'] || row['url'] || '';
        
        if (url && url.trim()) {
          try {
            const info = await fetchGalaxyInfo(url.trim(), forceRefresh);
            // Store the API results directly in the data object
            row['Version'] = info.version;
            row['Tool Count'] = info.toolCount;
            row['ConfigData'] = info.configData || {};
            
            // Log server status once for debugging/monitoring
            const statusSummary = info.version === 'Offline' ? 'OFFLINE' : 
                        info.version === 'Error' || info.version === 'API Error' ? 'ERROR' : 
                        info.version === 'Unknown' ? 'UNKNOWN' : 
                        info.version === 'Loading' ? 'LOADING' :
                        info.version === 'N/A' ? 'NO_URL' :
                        !info.version ? 'MISSING_VERSION' : 'ONLINE';
            
            console.log(`${row['Name']}: ${statusSummary} (Version: "${info.version}", ToolCount: "${info.toolCount}")`);
            
            // Additional debug for missing or problematic versions
            if (!info.version || info.version === '' || info.version === null) {
              console.warn(`${row['Name']}: Version field is empty/null/undefined`, info);
            }
          } catch (error) {
            console.error(`Error fetching Galaxy info for ${url.trim()}:`, error);
            row['Version'] = 'Error';
            row['Tool Count'] = 'Error';
            row['ConfigData'] = {};
            
            // Log server status for error case
            console.log(`${row['Name']}: ERROR (API fetch failed)`);
          }
        } else {
          row['Version'] = 'N/A';
          row['Tool Count'] = 'N/A';
          row['ConfigData'] = {};
          
          // Log server status for no URL case
          console.log(`${row['Name']}: NO_URL (No URL provided)`);
        }
        
        // Update progress and re-render after each completion
        updateProgress();
      });

      // Wait for all API calls to complete
      await Promise.all(promises);
      
      // Log final cache stats
      if (forceRefresh) {
        const finalCacheStats = getCacheStats();
        console.log(`Refresh completed. Cache now has ${finalCacheStats.validEntries} entries`);
      }
    }

    function renderTableRows(data) {
      const tbody = document.querySelector('#galaxy-table tbody');
      tbody.innerHTML = ''; // Clear existing rows
      
      if (!data || data.length === 0) {
        showNoResults();
        return;
      }
      
      data.forEach((row, index) => {
        const tr = document.createElement('tr');
        
        // Status column with icon and tooltip
        const tdStatus = document.createElement('td');
        const version = row['Version'] || 'Loading...';
        const toolCountForStatus = row['Tool Count'] || '';
        const statusInfo = getStatusIcon(version, toolCountForStatus);
        
        // Ensure we always have valid icon and tooltip
        const safeIcon = statusInfo?.icon || '⏳';
        const safeTooltip = statusInfo?.tooltip || 'Status unknown';
        
        tdStatus.innerHTML = `<span class="status-icon" style="font-size: 1.2rem;" title="${safeTooltip}">${safeIcon}</span>`;
        tdStatus.className = 'status-column';
        
        // Add debug logging for missing icons (only in development)
        if (!statusInfo || !statusInfo.icon) {
          console.warn(`Missing status icon for server ${row['Name']} with version: "${version}"`);
        }
        
        // Tier column (narrow to match status)
        const tdTier = document.createElement('td');
        const tierValue = row['Tier'] || '';
        let tierIcon = '';
        let tierTooltip = '';
        
        // Display tier icons based on tier value
        if (tierValue === '1') {
          tierIcon = '<i class="fas fa-globe" title="Tier 1 - Global/Major Server" style="color: #4caf50;"></i>';
          tierTooltip = 'Tier 1 - Global/Major Server';
        } else if (tierValue === '2') {
          tierIcon = '<i class="fas fa-university" title="Tier 2 - Institutional Server" style="color: #ff9800;"></i>';
          tierTooltip = 'Tier 2 - Institutional Server';
        } else if (tierValue === '3') {
          tierIcon = '<i class="fas fa-map-marker-alt" title="Tier 3 - Local Server" style="color: #2196f3;"></i>';
          tierTooltip = 'Tier 3 - Local Server';
        } else if (tierValue) {
          // Fallback for other tier values
          tierIcon = tierValue;
          tierTooltip = `Tier ${tierValue}`;
        }
        
        tdTier.innerHTML = tierIcon;
        tdTier.title = tierTooltip;
        tdTier.style.textAlign = 'center';
        tdTier.style.width = '50px';
        
        // Name column with favicon, hyperlink, and URL beneath
        const tdName = document.createElement('td');
        const serverName = row['Name'] || '';
        const url = row['URL'] || row['url'] || '';
        
        let faviconHtml = '';
        let nameContent = '';
        let urlContent = '';
        
        if (url && url.trim()) {
          // Only add protocol if none is present (preserve existing http:// or https://)
          let cleanUrl = url.trim();
          if (!cleanUrl.startsWith('http://') && !cleanUrl.startsWith('https://')) {
            cleanUrl = 'https://' + cleanUrl;
          }
          faviconHtml = `<img src="${cleanUrl}/favicon.ico" alt="" class="server-favicon" onerror="this.src='https://usegalaxy.org/favicon.ico';">`;
          
          // Make server name a hyperlink
          nameContent = `<a href="${cleanUrl}" target="_blank" style="color: inherit; text-decoration: none; font-weight: 500;">${serverName}</a>`;
          
          // Add URL beneath the name
          urlContent = `<a href="${cleanUrl}" target="_blank" class="server-url">${url.trim()}</a>`;
          
          tdName.innerHTML = `<div class="server-name-container">${faviconHtml}<div class="server-name-info">${nameContent}${urlContent}</div></div>`;
        } else {
          nameContent = `<span style="font-weight: 500;">${serverName}</span>`;
          urlContent = `<span class="server-url" style="color: #999;">No URL provided</span>`;
          tdName.innerHTML = `<div class="server-name-container">${faviconHtml}<div class="server-name-info">${nameContent}${urlContent}</div></div>`;
        }
        
        // Remove the URL column - it's now part of the Name column
        
        // Region column
        const tdRegion = document.createElement('td');
        tdRegion.textContent = row['Region'] || '';
        
        // Institution column with markdown link parsing and notes beneath
        const tdInstitution = document.createElement('td');
        const institutionText = row['Institution'] || '';
        const notesText = row['Notes'] || '';
        
        let institutionContent = parseMarkdownLinks(institutionText);
        let institutionHtml = '';
        
        if (institutionContent) {
          institutionHtml += `<div>${institutionContent}</div>`;
        }
        
        if (notesText) {
          institutionHtml += `<div class="institution-notes">${notesText}</div>`;
        }
        
        if (institutionHtml) {
          tdInstitution.innerHTML = `<div class="institution-info">${institutionHtml}</div>`;
        }
        
        // Remove the Notes column - it's now part of the Institution column
        
        // Info column (replaced contact with icons)
        const tdContact = document.createElement('td');
        const configData = row['ConfigData'] || {};
        
        let linksHtml = '<div class="contact-icons">';
        
        // Support icon (fa-question-circle)
        if (configData.support_url) {
          linksHtml += `<a href="${configData.support_url}" target="_blank" class="contact-icon" title="Support"><i class="fas fa-question-circle"></i></a>`;
        } else {
          linksHtml += `<span class="contact-icon disabled" title="Support not available"><i class="fas fa-question-circle"></i></span>`;
        }
        
        // Mailing list icon (fa-envelope)
        if (configData.mailing_join_addr) {
          linksHtml += `<a href="mailto:${configData.mailing_join_addr}" class="contact-icon" title="Mailing List"><i class="fas fa-envelope"></i></a>`;
        } else {
          linksHtml += `<span class="contact-icon disabled" title="Mailing list not available"><i class="fas fa-envelope"></i></span>`;
        }
        
        // Configuration icon (fa-cog) - opens server configuration API
        const serverUrl = row['URL'] || row['url'] || '';
        let configUrl = '';
        if (serverUrl && serverUrl.trim()) {
          let cleanUrl = serverUrl.trim().replace(/\/$/, '');
          // Only add protocol if none is present (preserve existing http:// or https://)
          if (!cleanUrl.startsWith('http://') && !cleanUrl.startsWith('https://')) {
            cleanUrl = 'https://' + cleanUrl;
          }
          configUrl = cleanUrl + '/api/configuration';
        }
        
        if (configUrl) {
          linksHtml += `<a href="${configUrl}" target="_blank" class="contact-icon" title="View Server Configuration"><i class="fas fa-cog"></i></a>`;
        } else {
          linksHtml += `<span class="contact-icon disabled" title="Configuration not available"><i class="fas fa-cog"></i></span>`;
        }
        
        // Lock/Unlock icon based on require_login
        if (configData.require_login === true) {
          linksHtml += `<span class="contact-icon" title="Login Required" style="color: #ff9800;"><i class="fas fa-lock"></i></span>`;
        } else if (configData.require_login === false) {
          linksHtml += `<span class="contact-icon" title="No Login Required" style="color: #4caf50;"><i class="fas fa-unlock"></i></span>`;
        }
        
        // Quota icon based on enable_quotas
        if (configData.enable_quotas === true) {
          linksHtml += `<span class="contact-icon" title="Quotas Enabled" style="color: #2196f3;"><i class="fas fa-chart-pie"></i></span>`;
        } else if (configData.enable_quotas === false) {
          linksHtml += `<span class="contact-icon" title="Quotas Disabled" style="color: #999;"><i class="fas fa-chart-pie"></i></span>`;
        }
        
        // Beacon integration icon based on enable_beacon_integration
        if (configData.enable_beacon_integration === true) {
          linksHtml += `<span class="contact-icon" title="Beacon Integration Enabled" style="color: #9c27b0;"><i class="fas fa-broadcast-tower"></i></span>`;
        } else if (configData.enable_beacon_integration === false) {
          linksHtml += `<span class="contact-icon" title="Beacon Integration Disabled" style="color: #999;"><i class="fas fa-broadcast-tower"></i></span>`;
        }
        
        linksHtml += '</div>';
        tdContact.innerHTML = linksHtml;
        tdContact.style.width = '100px';
        tdContact.style.textAlign = 'center';
        
        // Server column (without status icon since it's now separate)
        const tdVersion = document.createElement('td');
        if (version === 'Loading...') {
          tdVersion.innerHTML = `<span class="loading-indicator"></span> ${version}`;
        } else {
          // Use innerHTML to support the formatted version with start date
          tdVersion.innerHTML = version;
        }
        
        // Resources column (tools and genomes)
        const tdToolCount = document.createElement('td');
        const toolCount = row['Tool Count'] || 'Loading...';
        
        if (toolCount === 'Loading...') {
          tdToolCount.innerHTML = `<span class="loading-indicator"></span> ${toolCount}`;
        } else {
          // Use innerHTML to support multi-line display
          tdToolCount.innerHTML = toolCount;
        }
        
        // Center align info, server, and resources columns
        tdContact.style.textAlign = 'center';
        tdVersion.style.textAlign = 'center';
        tdToolCount.style.textAlign = 'center';
        
        // Apply color coding based on version status
        if (version === 'Offline') {
          tdVersion.style.color = '#f44336';
          // Only color resources if it's an error message, not actual tool/genome counts
          if (toolCount === 'Loading...' || toolCount === 'Offline' || typeof toolCount === 'string') {
            tdToolCount.style.color = '#f44336';
          }
        } else if (version === 'CORS Blocked') {
          tdVersion.style.color = '#ff9800';
          // Only color resources if it's an error message, not actual tool/genome counts
          if (toolCount === 'Loading...' || toolCount === 'CORS Blocked' || typeof toolCount === 'string') {
            tdToolCount.style.color = '#ff9800';
          }
          tdVersion.title = 'Server appears online but API calls blocked by browser CORS policy. Will work when deployed to GitHub Pages.';
          if (toolCount === 'CORS Blocked') {
            tdToolCount.title = 'Server appears online but API calls blocked by browser CORS policy. Will work when deployed to GitHub Pages.';
          }
        } else if (version === 'Unknown' || version === 'API Error' || version === 'Error') {
          tdVersion.style.color = '#ff9800';
          // Only color resources if it's an error message, not actual tool/genome counts
          if (toolCount === 'Loading...' || toolCount === 'Unknown' || toolCount === 'API Error' || toolCount === 'Error' || typeof toolCount === 'string') {
            tdToolCount.style.color = '#ff9800';
          }
        } else if (version === 'Loading...' || version === 'N/A') {
          tdVersion.style.color = '#999';
          // Only color resources if it's loading or N/A
          if (toolCount === 'Loading...' || toolCount === 'N/A') {
            tdToolCount.style.color = '#999';
          }
        } else {
          tdVersion.style.color = '#4caf50';
          // Don't override colors for resources when they contain formatted tool/genome counts
        }
        
        // Add loading class for progressive update effect
        if (version === 'Loading...' || toolCount === 'Loading...') {
          tr.classList.add('loading-row');
        }
        
        tr.appendChild(tdStatus);
        tr.appendChild(tdTier);
        tr.appendChild(tdName);
        tr.appendChild(tdRegion);
        tr.appendChild(tdInstitution);
        tr.appendChild(tdContact);
        tr.appendChild(tdVersion);
        tr.appendChild(tdToolCount);
        tbody.appendChild(tr);
      });
    }

    // Diagnostic function to check status icon issues (call from browser console)
    window.debugStatusIcons = function() {
      console.log('=== Galaxy Server Status Icon Debug ===');
      if (!currentData || currentData.length === 0) {
        console.log('No data available');
        return;
      }
      
      let redCount = 0, yellowCount = 0, greenCount = 0, otherCount = 0;
      
      currentData.forEach((row, index) => {
        const version = row['Version'];
        const toolCount = row['Tool Count'];
        const statusInfo = getStatusIcon(version, toolCount);
        const hasIssue = !statusInfo || !statusInfo.icon || statusInfo.icon === '';
        
        // Count status types
        if (statusInfo?.icon === '🔴') redCount++;
        else if (statusInfo?.icon === '🟡') yellowCount++;
        else if (statusInfo?.icon === '🟢') greenCount++;
        else otherCount++;
        
        console.log(`${index + 1}. ${row['Name']}:`);
        console.log(`   Version: "${version}" (type: ${typeof version})`);
        console.log(`   Tool Count: "${toolCount}" (type: ${typeof toolCount})`);
        console.log(`   Status Icon: "${statusInfo?.icon || 'MISSING'}" - ${statusInfo?.tooltip || 'NO_TOOLTIP'}`);
        
        // Highlight potential offline servers
        if (version === 'Offline' || toolCount === 'Offline') {
          console.log(`   🔴 OFFLINE SERVER DETECTED`);
        }
        
        if (hasIssue) {
          console.warn(`   ⚠️  ISSUE: Missing or empty status icon`);
        }
        console.log('');
      });
      
      console.log('=== STATUS SUMMARY ===');
      console.log(`🔴 Red (Offline): ${redCount}`);
      console.log(`🟡 Yellow (Issues): ${yellowCount}`);
      console.log(`🟢 Green (Online): ${greenCount}`);
      console.log(`Other: ${otherCount}`);
      console.log('=== End Debug ===');
    };
    
    // Function to refresh status icons for all servers
    window.refreshStatusIcons = function() {
      console.log('Refreshing status icons...');
      renderTableRows(filteredData.length > 0 ? filteredData : currentData);
      console.log('Status icons refreshed');
    };

    // Debug function to identify servers that should show red (offline) status
    window.debugOfflineServers = function() {
      console.log('=== Offline Servers Debug ===');
      if (!currentData || currentData.length === 0) {
        console.log('No data available');
        return;
      }
      
      const offlineServers = currentData.filter(row => {
        const version = row['Version'] || '';
        const toolCount = row['Tool Count'] || '';
        const versionStr = String(version).trim();
        const toolCountStr = String(toolCount).trim();
        
        // Check conditions that should result in red status
        const isVersionOffline = versionStr === 'Offline';
        const isToolsOffline = toolCountStr === 'Offline';
        const isBothApiError = versionStr === 'API Error' && toolCountStr === 'API Error';
        const isDnsError = versionStr.includes('ERR_NAME_NOT_RESOLVED') || versionStr.includes('ENOTFOUND') || 
                          versionStr.includes('SERVER_UNREACHABLE') || versionStr === 'DNS Error';
        const isBothOffline = isVersionOffline || (isToolsOffline && (versionStr === 'Unknown' || versionStr === 'Error' || versionStr === 'API Error' || versionStr === 'Timeout'));
        
        return isBothOffline || isBothApiError || isDnsError;
      });
      
      console.log(`Found ${offlineServers.length} servers that should show red (offline) status:`);
      
      offlineServers.forEach((row, index) => {
        const statusInfo = getStatusIcon(row['Version'], row['Tool Count']);
        const isCorrectRed = statusInfo?.icon === '🔴';
        
        console.log(`${index + 1}. ${row['Name']}:`);
        console.log(`   Version: "${row['Version']}"`);
        console.log(`   Tool Count: "${row['Tool Count']}"`);
        console.log(`   Current Icon: "${statusInfo?.icon}" ${isCorrectRed ? '✅' : '❌'}`);
        console.log(`   URL: "${row['URL'] || 'No URL'}"`);
        
        if (!isCorrectRed) {
          console.warn(`   ⚠️  SHOULD BE RED: Expected 🔴 but got ${statusInfo?.icon}`);
        }
        console.log('');
      });
      
      // Also check for servers currently showing red icons
      const currentlyRed = currentData.filter(row => {
        const statusInfo = getStatusIcon(row['Version'], row['Tool Count']);
        return statusInfo?.icon === '🔴';
      });
      
      console.log(`=== Currently showing red icons: ${currentlyRed.length} servers ===`);
      currentlyRed.forEach(row => {
        console.log(`- ${row['Name']}: Version="${row['Version']}", Tools="${row['Tool Count']}"`);
      });
    };

    // Test function to verify status icon logic (call from browser console)
    window.testStatusIcons = function() {
      console.log('=== Testing Status Icon Logic ===');
      
      const testCases = [
        { version: 'Offline', toolCount: 'Offline', expected: '🔴', description: 'Explicitly offline server' },
        { version: 'Unknown', toolCount: 'Offline', expected: '🔴', description: 'Tools offline + unknown version' },
        { version: 'API Error', toolCount: 'Offline', expected: '🔴', description: 'Tools offline + API error' },
        { version: 'API Error', toolCount: 'API Error', expected: '🔴', description: 'Both version and tools API error (completely unreachable)' },
        { version: 'ERR_NAME_NOT_RESOLVED', toolCount: 'Error', expected: '🔴', description: 'DNS error' },
        { version: 'SERVER_UNREACHABLE', toolCount: 'Error', expected: '🔴', description: 'Server unreachable' },
        { version: 'Unknown', toolCount: '1500 tools', expected: '🟡', description: 'Unknown version but has tools' },
        { version: 'API Error', toolCount: '2000 tools', expected: '🟡', description: 'API error but has tools' },
        { version: '21.05', toolCount: '3000 tools', expected: '🟢', description: 'Valid version and tools' },
        { version: 'CORS Blocked', toolCount: 'Error', expected: '🟡', description: 'CORS blocked' },
        { version: 'No URL', toolCount: 'No URL', expected: '⚫', description: 'No URL provided' },
        { version: 'Local Mode', toolCount: 'Local Mode', expected: '🏠', description: 'Local mode' },
        { version: 'Loading...', toolCount: 'Loading...', expected: '⏳', description: 'Loading state' }
      ];
      
      testCases.forEach((testCase, index) => {
        const result = getStatusIcon(testCase.version, testCase.toolCount);
        const isCorrect = result.icon === testCase.expected;
        
        console.log(`${index + 1}. ${testCase.description}:`);
        console.log(`   Input: version="${testCase.version}", toolCount="${testCase.toolCount}"`);
        console.log(`   Expected: ${testCase.expected}, Got: ${result.icon} ${isCorrect ? '✅' : '❌'}`);
        console.log(`   Tooltip: "${result.tooltip}"`);
        
        if (!isCorrect) {
          console.warn(`   ⚠️  TEST FAILED: Expected ${testCase.expected} but got ${result.icon}`);
        }
        console.log('');
      });
      
      console.log('=== Test Summary ===');
      const passed = testCases.filter(tc => getStatusIcon(tc.version, tc.toolCount).icon === tc.expected).length;
      console.log(`${passed}/${testCases.length} tests passed`);
    };
    
    // Debug function to verify version extraction logic with various response formats
    window.testVersionExtraction = function() {
      console.log('=== Testing Version Extraction Logic ===');
      
      const testCases = [
        {
          name: 'TreeGenes format',
          data: {"version_major": "20.01", "extra": {}},
          expected: '20.01'
        },
        {
          name: 'Standard numeric format',
          data: {"version_major": 21, "version_minor": 5, "version_micro": 0},
          expected: '21.5.0'
        },
        {
          name: 'Modern Galaxy format',
          data: {"version_major": 22, "version_minor": 1},
          expected: '22.1'
        },
        {
          name: 'Direct version field',
          data: {"version": "23.0.1"},
          expected: '23.0.1'
        },
        {
          name: 'Galaxy version field',
          data: {"galaxy_version": "20.09"},
          expected: '20.09'
        },
        {
          name: 'Nested data structure',
          data: {"data": {"version": "19.05"}},
          expected: '19.05'
        },
        {
          name: 'Mixed format (string major + numeric minor)',
          data: {"version_major": "21.01", "version_minor": 2},
          expected: '21.01.2'
        }
      ];
      
      testCases.forEach((testCase, index) => {
        console.log(`\n${index + 1}. Testing: ${testCase.name}`);
        console.log(`   Input:`, testCase.data);
        
        // Simulate the version extraction logic
        let version = 'Unknown';
        const versionData = testCase.data;
        
        // Handle version_major as a complete version string (like TreeGenes "20.01")
        if (versionData.version_major) {
          version = versionData.version_major;
          // If version_minor also exists as a separate field, append it
          if (versionData.version_minor && typeof versionData.version_minor === 'number') {
            version += `.${versionData.version_minor}`;
          }
          // If version_micro also exists, append it
          if (versionData.version_micro) {
            version += `.${versionData.version_micro}`;
          }
        } 
        // Standard modern Galaxy API version fields (both major and minor as numbers)
        else if (versionData.version_major && versionData.version_minor) {
          version = `${versionData.version_major}.${versionData.version_minor}`;
          if (versionData.version_micro) {
            version += `.${versionData.version_micro}`;
          }
        } 
        // Direct version field
        else if (versionData.version) {
          version = versionData.version;
        } 
        // Galaxy-specific version field
        else if (versionData.galaxy_version) {
          version = versionData.galaxy_version;
        }
        // Check for version in nested data structures
        else if (versionData.data && versionData.data.version) {
          version = versionData.data.version;
        }
        
        const isCorrect = version === testCase.expected;
        console.log(`   Expected: "${testCase.expected}"`);
        console.log(`   Got: "${version}" ${isCorrect ? '✅' : '❌'}`);
        
        if (!isCorrect) {
          console.warn(`   ⚠️  EXTRACTION FAILED`);
        }
      });
      
      console.log('\n=== Version Extraction Test Complete ===');
    };

    // Test function specifically for TreeGenes Galaxy server
    window.testTreeGenes = async function() {
      console.log('=== Testing TreeGenes Galaxy Server ===');
      
      const url = 'https://treegenes.cam.uchc.edu';
      console.log(`Testing URL: ${url}`);
      
      try {
        // Test the fetchGalaxyInfo function directly
        const result = await fetchGalaxyInfo(url, true); // Force refresh
        console.log('TreeGenes fetchGalaxyInfo result:', result);
        
        // Check if we got the expected version
        if (result.version && result.version !== 'Unknown' && result.version !== 'API Error') {
          console.log(`✅ SUCCESS: Got version "${result.version}"`);
        } else {
          console.log(`❌ FAILED: Got version "${result.version}"`);
        }
        
        return result;
        
      } catch (error) {
        console.error('TreeGenes test error:', error);
        return null;
      }
    };

    // Direct test of TreeGenes configuration data
    window.testTreeGenesConfig = async function() {
      console.log('=== Testing TreeGenes Configuration Directly ===');
      
      try {
        const corsProxy = 'https://cors-anywhere.herokuapp.com/';
        const configUrl = `${corsProxy}https://treegenes.cam.uchc.edu/api/configuration`;
        
        console.log(`Fetching: ${configUrl}`);
        const response = await fetch(configUrl);
        const configData = await response.json();
        
        console.log('Raw config data (server_startttime):', configData.server_startttime);
        console.log('Type:', typeof configData.server_startttime);
        
        // Test our parsing function
        const startTime = configData.server_startttime;
        console.log('Testing formatServerStartTime with:', startTime);
        const formatted = formatServerStartTime(startTime);
        console.log('Formatted result:', formatted);
        
        return { raw: startTime, formatted: formatted };
        
      } catch (error) {
        console.error('TreeGenes config test error:', error);
        return null;
      }
    };

    // Test function for timestamp parsing
    window.testTimestampParsing = function() {
      console.log('=== Testing Timestamp Parsing ===');
      
      const testCases = [
        // TreeGenes specific case
        { input: 1714584014, expected: 'May 1, 2024', note: 'TreeGenes timestamp' },
        { input: '1714584014', expected: 'May 1, 2024', note: 'TreeGenes timestamp as string' },
        
        // ISO string formats
        { input: '2024-01-15T10:30:00Z', expected: 'Jan 15, 2024' },
        { input: '2024-01-15T10:30:00.000Z', expected: 'Jan 15, 2024' },
        { input: '2024-01-15 10:30:00', expected: 'Jan 15, 2024' },
        
        // Unix timestamps in seconds
        { input: 1705315800, expected: 'Jan 15, 2024' }, // seconds
        { input: '1705315800', expected: 'Jan 15, 2024' }, // seconds as string
        
        // Unix timestamps in milliseconds
        { input: 1705315800000, expected: 'Jan 15, 2024' }, // milliseconds
        { input: '1705315800000', expected: 'Jan 15, 2024' }, // milliseconds as string
        
        // Edge cases
        { input: 0, expected: '' }, // Should be rejected (too old)
        { input: '0', expected: '' }, // Should be rejected (too old)
        { input: null, expected: '' },
        { input: undefined, expected: '' },
        { input: '', expected: '' },
        { input: 'invalid', expected: '' },
        
        // Potential problematic values that might cause "1970" dates
        { input: 946684800, expected: 'Jan 1, 2000' }, // Y2K in seconds
        { input: 946684800000, expected: 'Jan 1, 2000' }, // Y2K in milliseconds
      ];
      
      testCases.forEach((testCase, index) => {
        const result = formatServerStartTime(testCase.input);
        const isCorrect = result === testCase.expected;
        
        console.log(`Test ${index + 1}: ${JSON.stringify(testCase.input)} → "${result}"`);
        console.log(`   Expected: "${testCase.expected}" ${isCorrect ? '✅' : '❌'}`);
        if (testCase.note) {
          console.log(`   Note: ${testCase.note}`);
        }
        
        if (!isCorrect) {
          console.warn(`   ⚠️  TIMESTAMP PARSING FAILED`);
          
          // Debug info for failed cases
          if (typeof testCase.input === 'number' || !isNaN(Number(testCase.input))) {
            const numValue = Number(testCase.input);
            console.log(`   Debug: numValue=${numValue}, < 1e10? ${numValue < 1e10}`);
            console.log(`   Debug: Date(numValue * 1000)=${new Date(numValue * 1000)}`);
            console.log(`   Debug: Date(numValue)=${new Date(numValue)}`);
          }
        }
      });
      
      console.log('\n=== Timestamp Parsing Test Complete ===');
    };

    window.addEventListener('DOMContentLoaded', () => {
      loadSpreadsheetData();
    });
  </script>
</body>
</html>
